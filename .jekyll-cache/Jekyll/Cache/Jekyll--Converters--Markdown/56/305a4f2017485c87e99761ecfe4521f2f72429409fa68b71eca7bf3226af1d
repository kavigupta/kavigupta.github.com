I"<p>OK, so to continue our Infsaboting.</p>

<h3 id="correction">Correction</h3>

<p>I made a mistake last time. I included <code>SwitchInt</code>, a way to switch on values of <code>ExprDir</code>, which is ridiculous since an <code>ExprDir</code> can only be constructed as a constant or an <code>if</code> branch to begin with.</p>

<p>So just imagine that I never did that.</p>

<h2 id="guess-and-check">Guess and Check</h2>

<p>OK, so how should our AI construct these syntax trees? At a very high level, we want to be able to 1) assess trees against collections of trees and 2) modify them randomly. We can represent this as a pair of types:</p>

<pre><code class="language-haskell">asses :: [RP] -&gt; RP -&gt; Double
modify :: RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>I think the implementation of <code>asses</code> should be pretty clear: simply find the win rate (given that we can simulate an unlimited number of games).</p>

<p>Modify, on the other hand, is a little more complicated. There are a few ways a tree can be modified:</p>

<ul>
  <li>Modify the value of a constant to be something else.</li>
  <li>Modify the value of a field to point to something else or a field</li>
  <li>Add leaves to the tree</li>
  <li>Remove leaves as a simplification step</li>
</ul>

:ET