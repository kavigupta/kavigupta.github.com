I""<h2 id="whats-a-monoid">What‚Äôs a Monoid?</h2>

<p>A monoid is a set \(M\) with an identity element \(e : M\) and an operation \(* : M \to M \to M\), where we have the laws:</p>

<ul>
  <li>\(x * e = x\)</li>
  <li>\(e * x = x\)</li>
  <li>\(x * (y * z) = (x * y) * z\)</li>
</ul>

<p>We write a monoid as a tuple \((M, e, * )\). Some example monoids (written in pseudo-Haskell) are</p>

<pre><code class="language-haskell">(Int, 0, (+))
(Int, 1, (*))
(Bool, True, (||))
((), (), \x y -&gt; ())
([a], [], (++))
</code></pre>

<!--end excerpt-->

<h2 id="counting-pseudomonoids">Counting Pseudomonoids</h2>

<p>We define a pseudomonoid as a pair \((e, * )\) that doesn‚Äôt necessarily follow any laws:</p>

<pre><code class="language-haskell">type Pseudomonoid a = (a, (a, a) -&gt; a)
</code></pre>

<p>Counting the number of Pseudomonoids is not particularly difficult. If we define \(|A|\) to be the number of elements of a given type, we know that</p>

<ul>
  <li>\(|(A, B)| = |A||B|\)</li>
  <li>\(|A \to B| = |B| ^ {|A|}\)</li>
</ul>

<p>(The first one is a fairly standard result in combinatorics, the second one might require some work to prove. I‚Äôm going to leave both as an exercise. Yeah, I know, <a href="http://jwilson.coe.uga.edu/emt668/emat6680.f99/challen/proof/proof.html">proof by logic‚Ä¶</a>).</p>

<p>In any case, using these facts, we can easily calculate</p>

<pre><code class="language-haskell">| Pseudomonoid a | = a * a ^ (a * a) = a ^ (a^2 + 1)
</code></pre>

<h2 id="counting-monoids-try-1">Counting Monoids (Try 1)</h2>

<p>OK, so that was easy, and useless. Our goal is to count <em>monoids</em>, not some lawless structure resembling a monoid.</p>

<p>So, let‚Äôs define some laws:</p>

<pre><code class="language-haskell">monoidLaws :: forall a. (Enumerable a, Eq a) =&gt; Pseudomonoid a -&gt; Bool
monoidLaws (e, val) = idLaws &amp;&amp; assocLaw
    where
    idLaws = forAll $ \x -&gt; x +++ e == x &amp;&amp; e +++ x == x
    assocLaw = forAll $ \x y z -&gt; x +++ (y +++ z) == (x +++ y) +++ z
    (+++) = curry val
</code></pre>

<p>where we define the helper functions:</p>

<pre><code class="language-haskell">class ForAll b where
    forAll :: (Enumerable a) =&gt; (a -&gt; b) -&gt; Bool

instance ForAll Bool where
    forAll f = all f enumerate

instance (Enumerable a, ForAll b) =&gt; ForAll (a -&gt; b) where
    forAll f = forAll $ \x -&gt; forAll $ \y -&gt; f x y
</code></pre>

<p>We can then define a list of monoids over a set:</p>

<pre><code class="language-haskell">monoids :: (Eq a, FinitelyEnumerable a) =&gt; [Pseudomonoid a]
monoids = filter monoidLaws enumerate
</code></pre>

<p>We then define some test types representing finite numbers of elements (a little more systematic than <code>data Four = A | B | C | D</code>):</p>

<pre><code class="language-haskell">type Z = Void
data S x = Z | S x deriving(Eq, Show)

type One = S Z
type Two = S One
type Three = S Two
type Four = S Three

instance Enumerable Void where enumerate = []
instance FinitelyEnumerable Void where cardinality = 0
instance (Enumerable a) =&gt; Enumerable (S a) where enumerate = Z : (S &lt;$&gt; enumerate)
instance (FinitelyEnumerable a) =&gt; FinitelyEnumerable (S a) where
    cardinality = Tagged . (+1) . unTagged $ (cardinality :: Tagged a Integer)
</code></pre>

<p>And some testing functions:</p>

<pre><code class="language-haskell">timeCount :: String -&gt; Int -&gt; IO ()
timeCount label value = do
    start &lt;- getPOSIXTime
    putStrLn $ label ++ ": Counted " ++ " " ++ show value ++ " monoids"
    end &lt;- getPOSIXTime
    putStrLn . ("Completed in " ++) . show $ end - start

firstTry :: IO ()
firstTry = do
    timeCount "1" . length $ (monoids :: [Pseudomonoid One])
    timeCount "2" . length $ (monoids :: [Pseudomonoid Two])
    timeCount "3" . length $ (monoids :: [Pseudomonoid Three])
    timeCount "4" . length $ (monoids :: [Pseudomonoid Four])
</code></pre>

<p>The result is the following output:</p>

<pre><code>1: Counted  1 monoids
Completed in 0.000051s
2: Counted  4 monoids
Completed in 0.000062s
3: Counted  33 monoids
Completed in 0.017308s
&lt;wait 2 minutes&gt;
^C
</code></pre>

<p>OK, so why is this happening? Well, we know that the total number of Pseudomonoids is \(a ^ {a ^2 + 1}\), which is 1 for 1, 32 for 2, 59049 for 3, and <em>17179869184 for 4</em>! Since my computer can‚Äôt easily search through 17 billion values testing each of 64 possible values (checking associativity), this takes a long amount of time.</p>

<h2 id="identity-pseudomonoids">Identity Pseudomonoids</h2>

<p>OK, so that‚Äôs way too many monoids to go through. Let‚Äôs try to see if we can eliminate some of them. The identity restriction seems to be an easy one to ensure, because it only contains one variable. We therefore define an identity pseudomonoid as a pseudomonoid \(e, * \) satisfying \(a * e = e * a = a\).</p>

<p>To see how the identity restriction affects the pseudomonoid, we can look at a ‚Äúmultiplication table‚Äù of the monoid.</p>

<p><img src="/resources/2016-07-20/identity.png" /></p>

<p>Since we know the value of the function on green squares, if we know the value of the function on orange squares, we know the value of the function everywhere. We then have the definition <code>IdentityPsuedomonoid x = x * x ^ ((x-1)^2)</code>. Since subtracting one from a type isn‚Äôt well-defined, we instead use the definition <code>IdentityPsuedomonoid (x + 1) = (x + 1) * (x + 1) ^ (x^2)</code>, which can be encoded in Haskell as follows:</p>

<pre><code class="language-haskell">type family IdentityPsuedomonoid m :: *
type instance IdentityPsuedomonoid (S a) = (S a, (a, a) -&gt; S a)
</code></pre>

<p>We can now define a function from IdentityPsuedomonoids to Psuedomonoids:</p>

<pre><code class="language-haskell">extend :: forall a. (Enumerable a, Eq a) =&gt; IdentityPsuedomonoid (S a) -&gt; Pseudomonoid (S a)
extend (e, op) = (e, op')
    where
    op' :: (S a, S a) -&gt; S a
    op' (u, v)
        | u == e    = v
        | v == e    = u
        | otherwise = op (inject u, inject v)
    inject :: S a -&gt; a
    inject = match (delete e enumerate) enumerate
    match :: forall u v. (Eq u, Eq v) =&gt; [u] -&gt; [v] -&gt; u -&gt; v
    match [] _ _ = error "match: nonenumeration provided"
    match _ [] _ = error "match: not enough matchables"
    match (x:xs) (y:ys) v = if x == v then y else match xs ys v
</code></pre>

<p>Wow, that‚Äôs ugly! We can see that a lot of the issue is the arbitrary choice of a monoid identity element. Since the choice of an identity element is arbitrary (monoids are still monoids if you permute the labels), we can simply fix it to a specific value (say Z), count the resulting monoids, and then multiply by the number of elements in the set.</p>

<p>A simpler data type can be used (since there is no need to specify an identity).</p>

<pre><code class="language-haskell">type family IdentityPsuedomonoid' m :: *
type instance IdentityPsuedomonoid' (S a) = (a, a) -&gt; S a
</code></pre>

<p>And extend is heavily simplified!</p>

<pre><code class="language-haskell">extend' :: forall a. (Enumerable a, Eq a) =&gt; IdentityPsuedomonoid' (S a) -&gt; Pseudomonoid (S a)
extend' op = (Z, op')
    where
    op' :: (S a, S a) -&gt; S a
    op' (Z, y) = y
    op' (x, Z) = x
    op' (S x, S y) = op (x, y)
</code></pre>

<p>Finalizing the code (note the multiplicative factor in each case):</p>

<pre><code class="language-haskell">monoids' :: (Eq a, FinitelyEnumerable a) =&gt; [Pseudomonoid (S a)]
monoids' = filter monoidLaws (map extend' enumerate)

secondTry :: IO ()
secondTry = do
    timeCount "1" . (*1) . length $ (monoids' :: [Pseudomonoid One])
    timeCount "2" . (*2) . length $ (monoids' :: [Pseudomonoid Two])
    timeCount "3" . (*3) . length $ (monoids' :: [Pseudomonoid Three])
    timeCount "4" . (*4) . length $ (monoids' :: [Pseudomonoid Four])
    timeCount "5" . (*5) . length $ (monoids' :: [Pseudomonoid Five])
</code></pre>

<p>And it works for 4! Unfortunately not as well for 5.</p>

<pre><code>1: Counted  1 monoids
Completed in 0.000141s
2: Counted  4 monoids
Completed in 0.000047s
3: Counted  33 monoids
Completed in 0.001292s
4: Counted  624 monoids
Completed in 1.273906s
&lt;wait 2 minutes&gt;
^C
</code></pre>

<h2 id="a-closed-form-solution-perhaps">A closed form solution, perhaps?</h2>

<p>Well, there might be one, but I‚Äôm certainly not one to provide it. I didn‚Äôt realize while writing this post that the counting the number of monoids over a set is an open problem! (Also, I posed the problem slightly differently, in the standard formulation, we count <em>isomorphic</em> monoids).</p>

<p>But in any case, I hope the trip down Haskell lane was fun!</p>

:ET