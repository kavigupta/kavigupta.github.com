I"†<p>OK, so to continue our Infsaboting.</p>

<h3 id="correction">Correction</h3>

<p>I made a mistake last time. I included <code>SwitchInt</code>, a way to switch on values of <code>ExprDir</code>, which is ridiculous since an <code>ExprDir</code> can only be constructed as a constant or an <code>if</code> branch to begin with.</p>

<p>So just imagine that I never did that.</p>

<h2 id="guess-and-check">Guess and Check</h2>

<p>OK, so how should our AI construct these syntax trees? At a very high level, we want to be able to 1) assess trees against collections of trees and 2) modify them randomly. We can represent this as a pair of types:</p>

<pre><code class="language-haskell">asses :: [RP] -&gt; RP -&gt; Double
modify :: RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>I think the implementation of <code>asses</code> should be pretty clear: simply find the win rate (given that we can simulate an unlimited number of games).</p>

<p>Modify, on the other hand, is a little more complicated. There are a few ways a tree can be modified:</p>

<ul>
  <li>Modify the value of a constant to be something else.</li>
  <li>Modify the value of a field to point to something else or a field</li>
  <li>Add leaves to the tree</li>
  <li>Remove leaves as a simplification step</li>
</ul>

<!--end excerpt-->

<p>It might seem as if some of these factors might be aided by adding a field to everything that tracks typical values of the course of the application at different points within the tree. In this way, one can tell how big a difference between two strategies are. We can actually pretty easily keep track of this separately by recording a list of <code>KnownState</code>s from our simulations. For now, we‚Äôll just keep of all states or some random subset.</p>

<pre><code class="language-haskell">type HistoricalStates = [KnownState]
</code></pre>

<h2 id="shopping-list-for-functions">Shopping List for Functions</h2>

<p>Overall, we want to generate simpler strategies. But what do we mean by ‚Äúsimple‚Äù? Well, we can define complexity as the number of leaves of an expression tree:</p>

<pre><code class="language-haskell">complexity :: RP -&gt; Int
</code></pre>

<p>We might also want to be able to check what happens with small changes to individual parameters. To do this, we return a vector of slightly modified values where each parameter is a dimension.</p>

<pre><code class="language-haskell">getDeltas :: Ratio -&gt; RP -&gt; [RP]
</code></pre>

<p>We also want to be able to apply perturbations to an <code>RP</code>:</p>

<pre><code class="language-haskell">applyDeltas :: [Ratio Int] -&gt; RP -&gt; RP
</code></pre>

<p>Using these two techniques we can find a local maximum by something akin to Euler‚Äôs method for differential equations.</p>

<p>We also want to be able to switch between constants and parameters that make sense given context easily. For this, we can provide a typical set of <code>KnownState</code>s that can be used to find some parameter that would be similar and substitute it in. For simplicity, we‚Äôll only change one at a time.</p>

<pre><code class="language-haskell">constantToParameter :: HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>This is a little out of order, but simplification should work in a similar manner, replacing complex sections of tree with constants or parameters.</p>

<pre><code class="language-haskell">simplify :: HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>In fact, <code>simplify</code> can be seen as a more general form of <code>constantToParameter</code>; we can simply require some threshold determining whether or not a parameter or constant is ‚Äúclose enough‚Äù to be considered the same as a tree or not.</p>

<pre><code class="language-haskell">data GeneratorParameters = GeneratorParameters {
    closeEnoughThreshold :: Ratio Int
}

simplify :: GeneratorParameters -&gt; HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>Finally, we want the ability to complicate a given expression tree.</p>

<p>This can be accomplished most atomically by defining a function <code>complicate</code> that is allowed to make structural but non-effective changes, e.g.,</p>
<ul>
  <li><code>x -&gt; 1 * x, x / 1, 0 + x, x - 0</code></li>
  <li><code>x -&gt; if &lt;some bool expression&gt; then x else x</code></li>
  <li><code>b -&gt; b &amp;&amp; True, b || False</code></li>
</ul>

<p>This will accept an integer argument of how much to complicate its tree.</p>

<pre><code class="language-haskell">complicate :: Int -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>Now, in mentioning everything above, glossed over some things. For example, most parameters accept some sort of argument, so generating them requires said argument. Additionally, <code>&lt;some bool expression&gt;</code> will need to actually be filled in in the redundant branch seen above. So we need some way to randomly generate parts of a tree</p>

<pre><code class="language-haskell">randomlyGenerate :: StdGen -&gt; (RP, StdGen)
</code></pre>

<p>In fact, this function is provided by the <code>Random</code> typeclass, so we can instead say</p>

<pre><code class="language-haskell">instance Random RP where
    ...
</code></pre>

<h2 id="an-expr-type-class">An <code>Expr</code> type class</h2>

<p>OK, so if you were looking carefully, that last type didn‚Äôt make much sense. I said we needed to be able to generate random elements of various types, but the definition I gave was specifically for <code>RP</code>. In fact, all the definitions I gave apply equally well to any of the various <code>Expr*</code> types.</p>

<p>Let‚Äôs therefore collate all these function definitions into a single typeclass:</p>

<pre><code class="language-haskell">class (Random a) =&gt; Expr a where
    complexity :: a -&gt; Int
    getDeltas :: Ratio Int -&gt; a -&gt; [a]
    applyDeltas :: [Ratio Int] -&gt; a -&gt; a
    constantToParameter :: HistoricalStates -&gt; a -&gt; StdGen -&gt; (a, StdGen)
    simplify :: HistoricalStates -&gt; a -&gt; StdGen -&gt; (a, StdGen)
    complicate :: Int -&gt; a -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>OK, so that‚Äô‚Äôs it for now. I‚Äôll cover implementation tomorrow after I typecheck this mess!</p>
:ET