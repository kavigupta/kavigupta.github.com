I"c<!--
```haskell
{-# LANGUAGE ScopedTypeVariables, AllowAmbiguousTypes, FlexibleInstances #-}
import Prelude hiding (fst, snd)
import Data.Void
```
-->

<h2 id="product-data-structures">Product Data Structures</h2>

<p>Product Types are a familiar occurrence for a programmer. For example, in Java, the type <code>int</code> \(\times\) <code>int</code> can be represented as:</p>

<pre><code class="language-Java">class IntPair {
    public final int first;
    public final int second;
    public IntPair(int first, int second) {
        this.first = first;
        this.second = second;
    }
}
</code></pre>

<!--end excerpt-->

<p>In C, the same type can be represented as:</p>

<pre><code class="language-C">typedef struct {
    const int first, second;
} int_pair;
</code></pre>

<p>In Haskell, it can be represented as</p>

<pre><code class="language-haskell">data IntPair = IntPair Int Int
</code></pre>

<p>Of course, a general product data type can also be defined in many languages. For brevity I am only going to include the Haskell version:</p>

<pre><code class="language-haskell">data P a b = P a b
</code></pre>

<p><code>P</code> is therefore a generic way to construct a product of any two types.</p>

<h2 id="products-in-category-theory">Products in Category Theory</h2>

<p>The above definitions of a product require a notion of elements of our objects (in this case types), which doesn’t make much sense for categories in general.</p>

<h3 id="spans">Spans</h3>

<p>But we can define a span as two morphisms from the generic container to the two values. As a picture:</p>

<p><img src="/resources/2016-05-08/span.svg.png" /></p>

<p>In Haskell, we want to make sure that our <code>s</code> has some connection to <code>a</code> and <code>b</code> so we parametrize it as so:</p>

<pre><code class="language-haskell">class Span s where
    fst :: s a b -&gt; a
    snd :: s a b -&gt; b
</code></pre>

<p>We can recover the traditional definitions of <code>fst</code> and <code>snd</code> as follows:</p>

<pre><code class="language-haskell">instance (Span (,)) where
    fst (x, _) = x
    snd (_, y) = y
</code></pre>

<p>In any case, a span is not sufficient to determine a product. We can also define instances for the following:</p>

<pre><code class="language-haskell">instance (Span ((,,) a)) where
    fst (_, x, _) = x
    snd (_, _, y) = y
</code></pre>

<p>Obviously, this is not a valid product, as it is inhabited by values with three distinct types.</p>

<h3 id="a-categorical-product">A Categorical Product</h3>

<p>In category theory, a product is defined as \(c\) in the following diagram (where a dashed line implies only one possible morphism).</p>

<p><img src="/resources/2016-05-08/product.svg.png" /></p>

<p>In any case, we have to define some function \(v\) for any span \(s’\) such that</p>

<p>\[\text{fst} \circ v = \text{fst}’\]
\[\text{snd} \circ v = \text{snd}’\]</p>

<p>In any case, we have the following Haskell definition, with the given law as well as the implicit law that there be only one way to implement <code>pFactor</code>.</p>

<pre><code class="language-haskell">class (Span s) =&gt; Product s where
    pFactor :: (Span s') =&gt; s' a b -&gt; s a b

lawProduct :: forall s s' a b. (Eq a, Eq b, Span s', Product s) =&gt; s' a b -&gt; Bool
lawProduct val' = fst val == fst val' &amp;&amp; snd val == snd val'
    where
    val :: s a b
    val = pFactor val'
</code></pre>

<p>We can confirm that tuples are indeed products.</p>

<pre><code class="language-haskell">instance Product (,) where
    pFactor val' = (fst val', snd val')
</code></pre>

<p>Note that there is no way to make <code>(_, x, y)</code> a product, because one would need to put a value into the first box of type <code>forall a. a</code> and there is no value of that type apart from <code>undefined</code>. If we use the type <code>(Int, x, y)</code> instead, we have several potential implementations, one for each value of <code>Int</code>. If we however use <code>((), x, y)</code> we have a valid product:</p>

<pre><code class="language-haskell">instance Product ((,,) ()) where
    pFactor val' = ((), fst val', snd val')
</code></pre>

<p>This type is completely isomorphic to <code>(x, y)</code>, so it is too a product. Since the <code>()</code> type has one element, this isomorphism is equivalent to <code>1 * x * y = x * y</code>.</p>

<h2 id="coproducts">Coproducts</h2>

<p>A common thing to do in category theory is to reverse all the arrows and see what happens. Doing so for a span gives us a cospan, which looks like this:</p>

<p><img src="/resources/2016-05-08/cospan.svg.png" /></p>

<p>and can be implemented like this:</p>

<pre><code class="language-haskell">class Cospan s where
    left :: a -&gt; s a b
    right :: b -&gt; s a b
</code></pre>

<p>Each of the functions defines a constructor. We can make <code>Either</code> an instance of <code>Cospan</code> by delegating <code>left</code> and <code>right</code> to constructors.</p>

<pre><code class="language-haskell">instance Cospan Either where
    left = Left
    right = Right
</code></pre>

<p>We can also define a triple choice function that is a cospan:</p>

<pre><code class="language-haskell">data TripleEither a b c = A a | B b | C c
    deriving (Show, Eq)

instance Cospan (TripleEither a) where
    left = B
    right = C
</code></pre>

<p>We can define a coproduct in a similar manner: by inverting the arrows of a product diagram.</p>

<p><img src="/resources/2016-05-08/coproduct.svg.png" /></p>

<p>In any case, we must have a function from the coproduct to any span</p>

<pre><code class="language-haskell">class (Cospan s) =&gt; Coproduct s where
    cpFactor :: (Cospan s') =&gt; s a b -&gt; s' a b

lawCoproduct :: forall s s' a b. (Eq (s' a b), Cospan s', Coproduct s) =&gt; a -&gt; b -&gt; Bool
lawCoproduct a b = cpFactor lhsA == rhsA &amp;&amp; cpFactor lhsB == rhsB
    where
    rhsA, rhsB :: s' a b
    rhsA = left a
    rhsB = right b
    lhsA, lhsB :: s a b
    lhsA = left a
    lhsB = right b
</code></pre>

<p>We can therefore implement <code>Either</code> as a coproduct as follows:</p>

<pre><code class="language-haskell">instance Coproduct Either where
    cpFactor (Left a) = left a
    cpFactor (Right a) = right a
</code></pre>

<p>Unlike before, there is no possible implementation for <code>TripleEither U</code> for any concrete type <code>U</code>. We would need to coerce a value of type <code>U</code> to a random value. However, we can take a hint from our Product Isomorphism and use the type with 0 elements, or <code>Void</code> as follows:</p>

<pre><code class="language-haskell">instance Coproduct (TripleEither Void) where
    cpFactor (A v) = absurd v
    cpFactor (B b) = left b
    cpFactor (C c) = right c
</code></pre>

<p>This implementation makes use of <code>absurd</code>, a function that takes advantage of the impossibility of generating a <code>Void</code> to basically bypass that scenario entirely.</p>

<h2 id="conclusion">Conclusion</h2>

<p>And there we have it, a categorical product and coproduct system defined in Haskell. If you want to try these out, you can find the source code <a href="/src/2016-05-08-Haskell-Classes-For-Products-And-Coproducts.hs">here</a>.</p>
:ET