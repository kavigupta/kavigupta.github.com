I"˘(<p>The scheme language is a programming language that is unique for being easy to parse. Every construct in scheme is of the form</p>

<pre><code>(keyword arg1 ... argn)
</code></pre>

<h2 id="our-subset">Our Subset</h2>

<p>We will start with some standard scheme expressions, which you can think about as being analogous to certain patterns in Python. For example instead of writing <code>a + b</code>, you write <code>(+ a b)</code>, where <code>+</code> is just the name of a function. Similarly, instead of writing <code>lambda x: x * 2</code> for the doubling function, you write <code>(lambda (x) (* 2 x))</code>. Just lambdas and function application are enough to perform any calculation, but we add a few more features for clarity: instead of <code>x = y</code> we write <code>(define x y)</code>, instead of <code>x if y else z</code> we write <code>(if y x z)</code> and instead of writing</p>

<pre><code class="language-python">x = f(y)
return x
</code></pre>

<p>we write <code>(begin (define x (f y)) x)</code>. The real scheme language has many more constructs, including ones that simulate python‚Äôs <code>def</code> statements, and some unique ones that allow you to assign variables in a local frame, simulate <code>elif</code> trees, have short-circuited <code>and/or</code> constructs, or even define your own language constructs. For brevity, we will stick to this subset, which is still very powerful.</p>

<!-- end excerpt -->

<h2 id="lexing">Lexing</h2>

<p>The first step in processing a scheme program is to split it up into a list of tokens. What we do is take an expression like <code>'(a b (c))'</code> and convert it into a list of tokens like <code>'(', 'a', 'b', '(', 'c', ')', ')'</code>.</p>

<p>To accomplish this, we first pad all the parentheses with space and replace all space-like characters with a space. We then split on spaces (and filter out empty tokens, which are produced when multiple spaces are consecutive).</p>

<pre><code class="language-python">def lex(text):
    text = re.sub("([()])", r" \1 ", re.sub(r"\s", " ", text))
    return [x for x in text.split(" ") if x]
</code></pre>

<h2 id="parsing">Parsing</h2>

<p>We now need to parse the string. If we have <code>'(a b (c))'</code>, we want to parse it to <code>['a', 'b', ['c']]</code> so we can process it in Python. Parsing scheme is fairly simple using recursion. Whenever we see a symbol or number, we just return and move on. Otherwise, we recursively call parse until we see an end parenthesis. For example, if we have the current state of our input</p>

<pre><code>(+ 2 (4) (* 5 3)) 2 3)
</code></pre>

<p>we parse by removing the <code>(</code> from the front, then parse <code>+</code>, <code>2</code>, <code>(4)</code>, and <code>(* 5 3)</code> before seeing the unmatched <code>)</code>. Then we return, having removed everything but the <code>2 3)</code>. This is implemented as follows:</p>

<pre><code class="language-python">def parse(text):
    text = lex(text)[::-1]
    def parse():
        start = text.pop()
        if start != '(':
            return start
        vals = []
        while text[-1] != ')':
            vals += [parse()]
        text.pop()
        return vals
    return parse()
</code></pre>

<p>The reason we reverse the text is so that <code>pop()</code> pops from the end rather than the front of the input stream.</p>

<h2 id="frames">Frames</h2>

<p>We need to define an environment diagram so that we can execute code. This is similar to a Python style environment diagram, which is a backwards pointing tree (children point towards the root via the parent annotation rather than the other way around).</p>

<p>To define a frame, we use the <code>defaultdict</code> class from python, which is like a dictionary except that when it can‚Äôt find a key, instead of raising a <code>KeyError</code>, it calls a 0 argument function you provide in the constructor and sets that as its value. We want to slightly modify this so that it calls a 1 argument function. Thus we define a frame as such:</p>

<pre><code class="language-python">class frame(defaultdict):
    def __init__(self, f):
        super().__init__(lambda: None)
        self.__function = f
    def __missing__(self, key):
        return self.__function(key)
</code></pre>

<p><code>defaultdict</code> calls the <code>__missing__</code> function when necessary, and in this case, it calls the parent function on a key. We can create a child frame for a given frame simply by saying <code>frame(lambda v: parent[v])</code>. We can now create a global frame as such:</p>

<pre><code class="language-python">global_frame = frame(int)
global_frame.update({"+" : add, "-" : sub, "*" : mul, "/" : floordiv, "=" : lambda x, y: x == y})
</code></pre>

<p>We do something a little hacky here by basically defining integers as just being variables that evaluate to the integer version of themselves via the function <code>int</code>. (this works as <code>int("123") == 123</code>).</p>

<h2 id="special-forms">Special Forms</h2>

<p>Now we need to somehow handle our special keywords (define, lambda, begin, if).</p>

<h3 id="define">Define</h3>

<p>We assume that we already have a function <code>seval</code> defined, which is the function that will eval a scheme expression. In scheme, <code>define</code> returns the variable being assigned to, for reasons of tradition.</p>

<pre><code class="language-python">def define(exp, env):
    env[exp[0]] = seval(exp[1])
    return exp[0]
</code></pre>

<h3 id="lambda">Lambda</h3>

<p>A lambda expression has no side effects, but must return a function. First we create a new frame, then we assign the operator to the operands, and then we run the body of the function in that frame and return the last value:</p>

<pre><code class="language-python">def slambda(exp, env):
    def do_lambda(*args):
        local_env = frame(lambda x: env[x])
        local_env.update(dict(zip(exp[0], args)))
        return [seval(u, local_env) for u in exp[1:]][-1]
    return do_lambda
</code></pre>

<h3 id="begin">Begin</h3>

<p>This is similar to <code>lambda</code> except that we don‚Äôt have any arguments or a new frame, and this one is simple enough to just write as a Python lambda function.</p>

<pre><code class="language-python">lambda exp, env: [seval(u, env) for u in exp][-1]
</code></pre>

<h3 id="if">If</h3>

<p>We can just directly map this to the equivalent Python construct.</p>

<pre><code class="language-python">lambda exp, env: seval(exp[1], env) if seval(exp[0], env) else seval(exp[2], env)
</code></pre>

<h3 id="putting-it-together">Putting it together</h3>

<p>We create a dictionary of special forms for easy access:</p>

<pre><code class="language-python">def define(exp, env):
    env[exp[0]] = seval(exp[1])
    return exp[0]
def slambda(exp, env):
    def do_lambda(*args):
        local_env = frame(lambda x: env[x])
        local_env.update(dict(zip(exp[0], args)))
        return [seval(u, local_env) for u in exp[1:]][-1]
    return do_lambda
special_forms = {
    "define" : define,
    "lambda" : slambda,
    "begin" : lambda exp, env: [seval(u, env) for u in exp][-1],
    "if" : lambda exp, env: seval(exp[1], env) if seval(exp[0], env) else seval(exp[2], env)
}
</code></pre>

<h2 id="eval-function">Eval Function</h2>

<p>To evaluate a parsed scheme tree, what we need to do is dependent on whether the input is a list or not. If we have a list, then we need to check if its first element is a special form, and if so run its special form function. Otherwise, we evaluate the first item as a function, then evaluate the rest of the items as its arguments, then call the function. If we don‚Äôt have a list, we just look up the current element in the current frame.</p>

<pre><code class="language-python">def seval(tree, env=global_frame):
    if isinstance(tree, list):
        func, *args = tree
        if func in special_forms:
            return special_forms[func](args, env)
        return seval(func, env)(*(seval(x, env) for x in args))
    return env[tree]
</code></pre>

<p>We can then run scheme by running <code>seval(parse(text))</code>.</p>

<h2 id="the-entire-interpreter">The Entire Interpreter</h2>

<p>The entire interpreter, which is just 50 lines, is as below:</p>

<pre><code class="language-python">from collections import defaultdict
from operator import *
import re

def lex(text):
    text = re.sub("([()])", r" \1 ", re.sub(r"\s", " ", text))
    return [x for x in text.split(" ") if x]
def parse(text):
    text = lex(text)[::-1]
    def parse():
        start = text.pop()
        if start != '(':
            return start
        vals = []
        while text[-1] != ')':
            vals += [parse()]
        text.pop()
        return vals
    return parse()
class frame(defaultdict):
    def __init__(self, f):
        super().__init__(lambda: None)
        self.__function = f
    def __missing__(self, key):
        return self.__function(key)
global_frame = frame(int)
global_frame.update({"+" : add, "-" : sub, "*" : mul, "/" : floordiv, "=" : lambda x, y: x == y})

def define(exp, env):
    env[exp[0]] = seval(exp[1])
    return exp[0]
def slambda(exp, env):
    def do_lambda(*args):
        local_env = frame(lambda x: env[x])
        local_env.update(dict(zip(exp[0], args)))
        return [seval(u, local_env) for u in exp[1:]][-1]
    return do_lambda
special_forms = {
    "define" : define,
    "lambda" : slambda,
    "begin" : lambda exp, env: [seval(u, env) for u in exp][-1],
    "if" : lambda exp, env: seval(exp[1], env) if seval(exp[0], env) else seval(exp[2], env)
}
def seval(tree, env=global_frame):
    if isinstance(tree, list):
        func, *args = tree
        if func in special_forms:
            return special_forms[func](args, env)
        return seval(func, env)(*(seval(x, env) for x in args))
    return env[tree]
</code></pre>

<p>Of course, a proper scheme interpreter, which has more features (see the section ‚ÄúSubset‚Äù), more possible types (like strings, symbols, lists, etc.), and better error handling (we crash on a lot of cases with <code>IndexError</code>s and <code>ValueError</code>s). In fact, that‚Äôs an entire project in 61a.</p>

<p>But I personally enjoy that you can get quite a few features in such a small amount of space.</p>

<p>Try it out on the following program!</p>

<pre><code>(begin
    (define factorial
        (lambda (x) (if (= 0 x) 1 (* x (factorial (- x 1))))))
    (factorial 40))
</code></pre>
:ET