I"Æ<p>So, a friend and I (I‚Äôm going to protect his anonymity in case he doesn‚Äôt want to be associated with the travesty that is what we ended up thinking up) were discussing ridiculous ideas for programming languages: you know the deal, writing C interpreters in Python, using only integers to represent everything, etc.</p>

<p>One idea, however, seemed a little less ridiculous to us (OK, just to me): a language in which there are two data types: Dictionary and String.</p>

<!--end excerpt-->

<h2 id="everything-is-a-dictionary">Everything is a dictionary</h2>

<p>Every dictionary has keys which are dictionaries and values which are dictionaries. Lists are just a special case of dictionary:</p>

<pre><code class="language-python">[a, b, c]
    == {'__len__' : '3', '0' : a, '1' : b, '2' : c}
</code></pre>

<p>And strings are just a special case of lists:</p>

<pre><code class="language-python">'Hello'
    == ['H', 'e', 'l', 'l', 'o']
    == {'__len__' : '5', '0' : 'H', '1' : 'e', '2' : 'l', '3' : 'l', '4', 'o'}
</code></pre>

<p>Integers, floating points, etc. are just special cases of strings, and objects are just special cases of dictionaries, where keys are attribute names and values are their values. In fact, the current environment is merely a dictionary of the current bindings and a parent frame.</p>

<p>Functions are themselves just dictionaries. For example, <code>add</code> is a dictionary which maps list of number inputs to a numeric output:</p>

<pre><code class="language-python">plus[['2','3']] == '5'
</code></pre>

<h2 id="types-of-dictionaries">Types of Dictionaries</h2>

<p>There are two basic types of dictionary.</p>

<ul>
  <li>Discrete and strictly finite. e.g., Strings. These dictionaries need no special marker.</li>
  <li>Continuous and lazy, potentially infinite. e.g., functions. These dictionaries contain the mapping <code>__lazy__ : 'True'</code></li>
</ul>

<h2 id="language-built-ins">Language built-ins</h2>

<h3 id="the-empty-dictionary">The empty dictionary</h3>

<p>An empty dictionary is built by using the directive <code>__empty__</code>. It produces a dictionary containing no keys and no values. <code>__empty__</code> itself is not a dictionary, it is merely replaced by the call to generate a new dictionary and use it in that context.</p>

<h3 id="strings">Strings</h3>

<p>Strings are built according to python string conventions. They can be represented with single or double quotes; both <code>"this"</code> and <code>'this'</code> should work. It contains the key <code>__len__</code> which maps to the length of the string as well as keys <code>0</code>, <code>1</code>, <code>2</code>‚Ä¶ up till one less than the value of <code>__len__</code>.</p>

<h3 id="contains">Contains</h3>

<p><code>&lt;dictionary&gt;[&lt;key&gt;]?</code> outputs <code>'True'</code> if the dictionary contains the key and <code>'False'</code> otherwise. Note that this does not check parent frames (see ‚ÄúGet‚Äù)</p>

<h3 id="nonlocal-directive">Nonlocal directive</h3>

<p>By convention, the dictionary <code>{'__nonlocal__' : 'True'}</code> is referred to as a ‚ÄúNonlocal Directive‚Äù.</p>

<h3 id="get">Get</h3>

<p><code>&lt;dictionary&gt;[&lt;key&gt;]</code> outputs the key associated with the given value. If the key is not in the dictionary or if it is associated with a nonlocal directive, it checks for a <code>__parent__</code> and looks it up there. If there is no <code>__parent__</code>, it raises a <code>KeyError</code> which results in the halting of the given code.</p>

<h3 id="put">Put</h3>

<p><code>&lt;dictionary&gt;[&lt;key&gt;] = &lt;value&gt;</code> associates the given key with the given value in the given dictionary. This does not check parent frames unless the given key is associated with a nonlocal directive, in which case it does. If there is no error, it raises a <code>KeyError</code>. It‚Äôs value is the empty dictionary.</p>

<h3 id="local">Local</h3>

<p><code>__local__</code> is the local frame, it can be discrete or continuous (see <code>__call__</code> for how this case can come to pass).</p>

<h3 id="if">If</h3>

<p><code>__if__[&lt;condition&gt;][&lt;ifso&gt;][&lt;ifelse&gt;]</code> evaluates the condition in the local environment, then conditionally evaluates the <code>ifso</code> and <code>ifelse</code> programs (text).</p>

<h3 id="call">Call</h3>

<p><code>__call__</code> is a higher-order dictionary that takes a sequence of lines of code (with the key <code>__program__</code>) and an environment (<code>__env__</code>) and outputs a continuous dictionary mapping input dictionaries to the result of executing the program on the given frame with the parent frame forced to be the given parent frame. The result is defined as the value of the last statement.</p>

<h2 id="an-example">An Example</h2>

<pre><code class="language-python">__local__['factorial'] = __empty__
__local__['factorial']['__program__']
    = '__if__ \
            [__local__["=="] \
                [__local__["n"]] \
                ["0"]] \
            ["\"1\""] \
            ["__local__[\"*\"] \
                [__local__[\"n\"]] \
                [__local__[\"factorial\"] \
                    [__local__[\"-\"] \
                        [__local__[\"n\"]] \
                        [\"1\"]]]"]'
__local__['factorial']['__env__'] = __local__
__local__['factorial'] = __call__[__local__['factorial']]
__local__['four'] = __empty__
__local__['four']['n'] = '4'
__local__['toprint'] = __empty__
__local__['toprint']['__toprint__']
    = __local__['factorial'][__local__['four']]
__local__['print'][__local__['toprint']]
# ^ Should print 24, given that "print" is defined
</code></pre>

<p>OK, so nothing beautiful. Hopefully, in a future post, we can look at sugaring and turning this into a practical language.</p>
:ET