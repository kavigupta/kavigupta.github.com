I"<p>Scheme is well known as a very simple programming language. The general concept behind scheme is that it is composed of S-expressions, or expressions of the form <code>(operator operand1 operand2 ... operandn)</code>, which can be nested.</p>

<p>This makes scheme relatively simple to parse and evaluate, however it does lead to some strange compromises on the style of programming. For example, rather than writing <code>12 * (2 + 3)</code>, you have to write <code>(* 12 (+ 2 3))</code>. And in a way, this is elegant in its simplicity.</p>

<p>But simplicity is overrated.</p>

<!-- end excerpt -->

<h2 id="homoiconicity-or-writing-a-scheme-program-to-write-a-scheme-program">Homoiconicity, or writing a scheme program to write a scheme program</h2>

<p>Scheme has this cool property of being a homoiconic language. This means that you can write scheme code that writes and modifies scheme code.</p>

<p>For example, take this function, which replaces the first element form a scheme expression with a <code>+</code>:</p>

<pre><code>(define (replace-with-plus code)
	(cons '+ (cdr code)))
</code></pre>

<p>Note that we just treat the code like any other scheme list. To call this function, we can just run</p>

<pre><code>scm&gt; (replace-with-plus '(- 2 3))
(+ 2 3)
</code></pre>

<p>Now, if we want to actually run this program, we can wrap it in an <code>eval</code> call as such:</p>

<pre><code>scm&gt; (eval (replace-with-plus '(- 2 3)))
5
</code></pre>

<h2 id="macros">Macros</h2>

<p>You’ll note that in the above, we have to quote the arguments and then eval the result. It turns out that there’s a construct in Scheme that will do this for you! Using the same replacing with + function, we can define</p>

<pre><code>(define-macro (replace-with-plus code)
	(cons '+ (cdr code)))
</code></pre>

<p>Note that this is the same definition, except that we have replaced <code>define</code> with <code>define-macro</code>. Now, Scheme handles the quoting of the arguments and the evaluation of the result for us as such:</p>

<pre><code>(replace-with-plus (- 2 3))
5
</code></pre>

<p>Pretty nifty, huh!</p>

<h2 id="infix-notation">Infix notation</h2>

<p>OK, but the post’s title is infix notation. Let’s say we want to be able to write <code>(12 * (2 + 3))</code> in scheme and have it evaluate the way it would in Python. To accomplish this, let’s define a function (not a macro for now) that takes in <code>(12 * (2 + 3))</code> and converts it into the scheme form <code>(* 12 (+ 2 3))</code>. First off, we need to identify which things are in fact infix notation:</p>

<pre><code>(define (infix? code)
	(and
		(list? code)
		(= (length code) 3)
		(member (cadr code) '(+ * - /, &gt;, &lt;, &gt;=, &lt;=, =))))
</code></pre>

<p>The idea here is that we check that the given piece of code is a list with 3 elements, and that its middle element is an operator. Now, let’s write the code to convert infix to prefix notation.</p>

<pre><code>(define (rearrange code)
	(list (cadr code) (car code) (caddr code)))
</code></pre>

<p>Where this code just places the elements in second, first, third order.</p>

<p>Now, we can put it together with a recursive function:</p>

<pre><code>(define (to-prefix-func code)
	(cond
		((infix? code) (to-prefix-func (rearrange code)))
		((list? code) (map to-prefix-func code))
		(else code)))
</code></pre>

<p>The idea behind this code is that if something is infix, we should rearrange it, then call ourselves to finish up the task, if something is a call expression, we should just look at every element, and otherwise, we’re at a base case and can just return.</p>

<p>Let’s try this out on our example:</p>

<pre><code>scm&gt; (to-prefix-func '(12 * (2 + 3)))
(* 12 (+ 2 3))
</code></pre>

<p>It works!</p>

<p>Finally, what we really want is a macro. We can just define one directly:</p>

<pre><code>(define-macro (to-prefix code) (to-prefix-func code))
</code></pre>

<p>Sadly we can’t just <code>(define-macro to-prefix to-prefix-func)</code> because of a technicality in the scheme language. Anyway, now we can run our scheme code:</p>

<pre><code>scm&gt; (to-prefix (12 * (2 + 3)))
60
</code></pre>

<p>And there you have it. Scheme’s power might be in its simplicity but with great power comes the ability to create complexity. Obviously, the usual disclaimer applies: <em>don’t write code like this</em>, but if you do, do it with macros!</p>

<h2 id="the-code">The code</h2>

<p>A fully runnable version of this is below: try copy-pasting it into <a href="http://scheme.cs61a.org">61A’s scheme interpreter</a> and check it out! (There are a few helpful functions defined at the end that we just kinda assumed the existence of above).</p>

<pre><code>(define (infix? code)
	(and
		(list? code)
		(= (length code) 3)
		(member (cadr code) '(+ * - /, &gt;, &lt;, &gt;=, &lt;=, =))))

(define (rearrange code)
	(list (cadr code) (car code) (caddr code)))

(define (to-prefix-func code)
	(cond
		((infix? code) (to-prefix-func (rearrange code)))
		((list? code) (map to-prefix-func code))
		(else code)))

(define-macro (to-prefix code)
	(to-prefix-func code))

(define (member elem lst)
	(cond
		((null? lst) #f)
		((eq? (car lst) elem) #t)
		(else (member elem (cdr lst)))))

(define (cadr lst) (car (cdr lst)))
(define (cddr lst) (cdr (cdr lst)))
(define (caddr lst) (car (cddr lst)))
</code></pre>
:ET