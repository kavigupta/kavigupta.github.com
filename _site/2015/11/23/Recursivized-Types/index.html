<!DOCTYPE html>
<html lang="en">
	<head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Recursivized Types &middot; That depends on what the definition of "=" is
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="That depends on what the definition of "=" is" href="/atom.xml">
</head>

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68543647-1', 'auto');
  ga('send', 'pageview');

</script>

	<body>
	<link rel="stylesheet" href="/highlighting/styles/default.css">
	<script src="/highlighting/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<div class="container content">
			<header class="masthead">
				<h3 class="masthead-title">
					<div class="header">
						<img src="/public/icon.png" alt="icon" style="width:50px;height:50px;vertical-align: middle;">
						<a href="/" title="Home" style = "vertical-align: middle">&nbsp;That depends on what the definition of "=" is</a>
					</div>
					<small></small>
				</h3>
			</header>

			<main>
				\(\newcommand{\th}{^\mathrm{th}}\)
				\(\newcommand{\false}{\mathrm{F}}\)
				\(\newcommand{\true}{\mathrm{T}}\)
				<article class="post">
  <h1 class="post-title">Recursivized Types</h1>
  <time datetime="2015-11-23T00:00:00-08:00" class="post-date">23 Nov 2015</time>
  <p>So, a short break from \(\varepsilon—\delta\).</p>

<p>Anyway, I’m going to look at Algebraic types in this section. Specifically, I am going to use Haskell types.</p>

<p>The provided code is all actual Haskell, in fact, I’m going to have to de-import the standard libraries because some of this is actually defined there. You can find all the code <a href="/src/2015-11-23-Recursive-Types.hs">here</a></p>

<!--
```haskell
{-# LANGUAGE FlexibleContexts, UndecidableInstances #-}

import Prelude(Show, show, (++))
```
-->

<h2 id="algebraic-types">Algebraic types</h2>

<p>I’ll start with a quick go-over of Haskell types. If you already know Haskell, feel free to skip this section.</p>

<h3 id="enumeration-types">Enumeration types</h3>

<p>Some types are enumerations of potential values.</p>

<p>A quick example is the trivial singleton type:</p>

<pre><code class="language-haskell">data Singleton = Single
    deriving Show
</code></pre>

<p>This is to be read as “there exists a type Singleton, which contains one element named Single.” The “deriving show” part is Haskell book keeping for those following along on their interpreters to be able to see things</p>

<p>Another example is</p>

<pre><code class="language-haskell">data Void
</code></pre>
<p>This is to be read as “there exists a type Void with no possible elements”</p>

<p>Yet another type is</p>

<pre><code class="language-haskell">data Bool = False | True
    deriving Show
</code></pre>

<p>This is to be read as “there exists a type Bool with the possible elements True and False.”</p>

<h3 id="structure-types">Structure types</h3>

<p>Types can be used as as structures, as such:</p>

<pre><code class="language-haskell">data Wrapper a = Wrap a
    deriving Show
</code></pre>

<p>This is to be read as “for every type <code>a</code> there exists a type <code>(Wrapper a)</code> with a single type constructor <code>Wrap</code> that takes an <code>a</code>”</p>

<p>A more complicated structure is</p>

<pre><code class="language-haskell">data Pair a b = ConsPair a b
    deriving Show
</code></pre>

<p>Which is similar to the previous one except that it contains two possible elements which can be of two different types.</p>

<h3 id="aside-kinds">Aside: Kinds</h3>

<p>Algebraic types have kinds.</p>

<ol>
  <li><code>Singleton</code>, <code>Void</code>, and <code>Bool</code> are concrete types in their own right.</li>
  <li><code>Wrapper</code> needs a type before it can become a type (nothing can be a <code>Wrapper</code> by itself).</li>
  <li><code>Pair</code> needs two types before it can become a type (nothing can be a <code>Pair</code> or <code>Pair Bool</code> by itself).</li>
</ol>

<p>We refer to the latter two cases as “higher-kinded types.”</p>

<p>We say that <code>Singleton</code>, <code>Void</code>, etc. have kind <code>*</code>. Types that need one type added on the end to be complete, such as <code>Wrapper</code> or <code>Pair Bool</code> have kind <code>* -&gt; *</code>. Types such as <code>Pair</code>, which needs two types to be complete, have kind <code>* -&gt; * -&gt; *</code>.</p>

<p>Note also that types such as</p>

<pre><code class="language-haskell">data TwoOfSame a = ConsTwoOfSame a a
</code></pre>

<p>have kind <code>* -&gt; *</code> rather than <code>* -&gt; * -&gt; *</code> because they only take one type argument. <code>TwoOfSame Bool Singleton</code> wouldn’t make any sense.</p>

<h3 id="mixing-structures-and-enumerations">Mixing Structures and Enumerations</h3>

<p>Algebraic types are a generalization of both systems, in which you can have multiple constructors, each of which can contain zero or multiple arguments.</p>

<p>A canonical example combines both forms to create something resembling the concept of <code>null</code> from Java or <code>None</code> from Python.</p>

<pre><code class="language-haskell">data Maybe a = Nothing | Just a
    deriving Show
</code></pre>

<p>Here, there is a combination of the enumeration and structure style. Interestingly, while, for example, <code>Just True :: Maybe Bool</code> (<code>::</code> is to be read as “is of type”), <code>Nothing :: Maybe a</code>, which means that it can take on any <code>Just</code> type (this is key to what we will do later).</p>

<h2 id="recursive-algebraic-types">Recursive Algebraic types</h2>

<p>Recursive types are similar to the examples shown, except that they can also contain themselves. For example, the not particularly efficient definition of the natural numbers (<a href="https://en.wikipedia.org/wiki/Peano_axioms">a natural number is either zero or the successor of another natural number</a>):</p>

<pre><code class="language-haskell">data Nat = Zero | Succ Nat
    deriving Show
</code></pre>
<p>Another algebraic type is a stream, which is defined as follows, which is basically an infinite list.</p>

<pre><code class="language-haskell">data Stream a = ConsStream a (Stream a)
    deriving Show
</code></pre>

<p>This only works because you can define values as follows, where in each case the same variable name refers to the same value:</p>

<pre><code class="language-haskell">trues = ConsStream True trues
falses = ConsStream False falses
alternating = ConsStream True (ConsStream False alternating)

elementAt (ConsStream value rest) Zero = value
elementAt (ConsStream value rest) (Succ x) = elementAt rest x
</code></pre>

<p>So if you ask for the (fifth element of trues), that reduces to the (fourth element of (the rest of trues)) which reduces to (the fourth element of trues), etc., until you get to the value <code>True</code>.</p>

<p>A potentially terminating list can be represented as follows:</p>

<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
    deriving Show
</code></pre>

<p>Here the list can possibly terminate because you can stop with <code>Nil</code>. For example, you can represent <code>[True, False, False]</code> as</p>

<pre><code class="language-haskell">exampleList = Cons True (Cons False (Cons False Nil))
</code></pre>

<p>You could also use stream-like circular definition for a list too, so streams are just a subset of lists.</p>

<h2 id="higher-kinded-type-parameters">Higher-kinded type parameters</h2>

<p>OK, one final bit of craziness before we get to our actual example. Let’s say we want to create a type representing the shape of another type.</p>

<pre><code class="language-haskell">data Shape f = Structure (f Singleton)
</code></pre>

<p>If we, for example, look at <code>Shape List</code>, we get the values <code>Structure Nil</code>, <code>Structure (Cons Single Nil)</code>, <code>Structure (Cons Single (Cons Single Nil))</code>, etc. Basically, we get a picture of what the type looks like independent of its elements.</p>

<p>Notice that on the right side of that equation we have <code>(f Singleton)</code> as a concrete value, meaning that <code>f</code> is of kind <code>* -&gt; *</code>. Therefore, <code>Shape</code> is of kind <code>(* -&gt; *) -&gt; *</code>.</p>

<p>Another example of a <code>(* -&gt; *) -&gt; *</code> is the <code>NullOf</code> type, which filters a type for only its nullary constructors, those which do not take a value.</p>

<pre><code class="language-haskell">data NullOf f = Null (f Void)
</code></pre>

<p>For example, the only possible value of <code>NullOf List</code> is <code>Null Nil</code> and the only possible value of <code>NullOf Just</code> is <code>Null Nothing</code>.</p>

<h2 id="a-general-encoding-of-recursive-types">A general encoding of Recursive Types</h2>

<p>You might notice a correspondence between the types <code>Maybe</code> and <code>Nat</code>:</p>

<pre><code class="language-haskellcomment">    data Maybe a = Nothing | Just a
    data Nat = Zero | Succ Nat
</code></pre>

<p>Basically, <code>Nat</code> is just <code>Maybe Nat</code>. We can encode the conversion from <code>Maybe</code> to <code>Nat</code> as follows:</p>

<pre><code class="language-haskell">data Recursive f = Recurse (f (Recursive f))
</code></pre>

<!--
```haskell
instance (Show (f (Recursive f))) => Show (Recursive f) where
    show (Recurse x) = "Recurse (" ++ show x ++ ")"
```
-->

<p>This definition means that for all types <code>f</code> of kind <code>* -&gt; *</code>, there exists a type called <code>Recursive f</code> (let’s call this <code>rf</code> for now) which contains a single element whose type is <code>f rf</code>. In other words, <code>Recursive</code> takes a type and returns a recursive version of that type.</p>

<p>Constructing a value of <code>Recursive *</code> at first seems difficult. For example, let us look at <code>Recursive Maybe</code>.</p>

<p>To construct a type of <code>Recursive Maybe</code> we need to have an element of type <code>Maybe (Recursive Maybe)</code>. The only element of this we have is <code>Nothing :: Maybe a</code>. We can therefore construct the value <code>Recurse Nothing :: Recursive Maybe</code>. Using this value we can construct the value <code>Just (Recurse Nothing) :: Maybe (Recursive Maybe)</code> and therefore the value <code>Recurse (Just (Recurse Nothing)) :: Recursive Maybe</code>. We can continue to build values in this manner:</p>

<pre><code class="language-haskell">zero' = Recurse Nothing
one' = Recurse (Just zero')
two' = Recurse (Just one')
three' = Recurse (Just two')
</code></pre>

<p>Notice that I used the names for numbers for these. This is to demonstrate their correspondence with the natural numbers:</p>

<pre><code class="language-haskell">zero = Zero
one = Succ Zero
two = Succ one
three = Succ two
</code></pre>
<p>Basically, <code>Zero</code> is <code>Nothing</code> and <code>Succ</code> is <code>Recurse . Just</code>, where <code>.</code> is function composition.</p>

<p>Interestingly, there is another possible value of these types</p>

<pre><code class="language-haskell">omega' = Recurse (Just omega')
omega = Succ omega
</code></pre>

<p>The name <code>omega</code> is used because this number is similar to <a href="https://en.wikipedia.org/wiki/Ordinal_number">one particular kind of infinity</a>. because of the way that it reacts to this definition of comparison:</p>

<pre><code class="language-haskell">_ &lt; Zero        = False
Zero &lt; Succ _   = True
Succ x &lt; Succ y = x &lt; y
</code></pre>

<p>As you can see, <code>x &lt; omega</code> is <code>True</code> for all <code>x</code> defined by <code>Succ (Succ (Succ ... Succ (Zero)))</code>. Note that <code>omega &lt; omega</code> will never evaluate since <code>omega &lt; omega</code> reduces to <code>Succ omega &lt; Succ omega</code>, which reduces to <code>omega &lt; omega</code>.</p>

<h2 id="recursivizing-types">Recursivizing Types</h2>

<p>To begin with, let’s look at the entirely contrived types:</p>

<pre><code class="language-haskell">data Constant a = Const
    deriving (Show)
data Empty a
</code></pre>

<p>We can see that there is one possible value for <code>Constant (Recursvie Constant)</code>, which is <code>Const</code>. Therefore, the only possible value for <code>Recursive Constant</code> is <code>Recurse Const</code>. Therefore, <code>Recursive Constant</code> is similar to the Singleton:</p>

<pre><code class="language-haskell">single = Single
single' = Recurse Const
</code></pre>

<p>Similarly, there is no value <code>Empty (Recursive Empty)</code> possible, so there is no possible value of <code>Recursive Empty</code>.</p>

<p>Let’s now look at a less contrived <code>* -&gt; *</code> type, Wrapper, and see how it works. <code>Recursive Wrapper</code> requires a value of <code>Wrapper (Recursive Wrapper)</code> in order to initialize. There is in fact only one way to do this:</p>

<pre><code class="language-haskell">wrappedRecurse = Recurse (Wrap wrappedRecurse)
</code></pre>

<p>This type is also basically <code>Singleton</code> since it only has one value</p>

<p>We can also use the partial application of <code>Pair</code> to a single type variable <code>a</code> and then construct a recursion of the pair. We can then analyze values of <code>Recurse (Pair Bool)</code>. At first, this doesn’t seem to work any better than <code>Recurse Wrap</code> because we need a value of <code>Pair Bool (RPair Bool)</code> before we can create a value of <code>RPair Bool</code>. However, since in this case each value also has a <code>Bool</code>, these form a stream:</p>

<pre><code class="language-haskell">trues' = Recurse (ConsPair True trues')
falses' = Recurse (ConsPair False falses')
alternating' = Recurse (ConsPair True (Recurse (ConsPair False alternating')))
</code></pre>

<p>Which is remarkably similar to our previous definitions:</p>

<pre><code class="language-haskellcomment">trues = ConsStream True trues
falses = ConsStream False falses
alternating = ConsStream True (ConsStream False alternating)
</code></pre>

<h2 id="finding-the-base-type-for-recursive-types">Finding the base type for recursive types</h2>

<p>So now we know (I’m using \(\equiv\) to mean that two types have the same structure):</p>

<ul>
  <li><code>Recurse Maybe</code> \(\equiv\) <code>Nat</code></li>
  <li><code>Recurse Constant</code> \(\equiv\) <code>Singleton</code></li>
  <li><code>Recurse Wrapper</code> \(\equiv\) <code>Singleton</code></li>
  <li><code>Recurse Empty</code> \(\equiv\) <code>Void</code></li>
  <li><code>Recurse Constant</code> \(\equiv\) <code>Stream</code></li>
</ul>

<p>But what is <code>List</code> equivalent to? We can look again at the definition of a list:</p>

<pre><code class="language-haskellcomment">data List a = Nil | Cons a (List a)
</code></pre>

<p>OK, so we need to have a type parameter representing the <code>a</code> and another to be eaten by <code>Recurse</code>.</p>

<pre><code class="language-haskellcomment">data PreList a self = ???
</code></pre>

<p>And we need to have some element <code>Nil</code>.</p>

<pre><code class="language-haskellcomment">data PreList a self = PreNil | ???
</code></pre>

<p>Now, we just need something to combine both the first and rest of the list</p>

<pre><code class="language-haskellcomment">data PreList a self = PreNil | PreCons a self
</code></pre>

<p>Hey, what’s on the right of the list looks a lot like a <code>Maybe</code> with two values instead of one! Here’s a final implementation</p>

<pre><code class="language-haskell">data PreList a self = PreList (Maybe (Pair a self))
    deriving (Show)

type RecurseList a = Recursive (PreList a)
</code></pre>

<p>Redoing our <code>[True, False, False]</code> example, we get:</p>

<pre><code class="language-haskell">exampleList'
    = Recurse (PreList (Just (ConsPair
        True
        (Recurse (PreList (Just (ConsPair
            False
            (Recurse (PreList (Just (ConsPair
                False
                (Recurse (PreList Nothing)))))))))))))
</code></pre>

<p>No reasonable person (except (maybe (a (Lisp (fanatic))))) would say that the above code is pretty, but it is clear that <code>Recursive (PreList a)</code> \(\equiv\) <code>List</code>.</p>

<h2 id="exercises">Exercises</h2>

<ul>
  <li>Find the de-recursified forms of</li>
</ul>

<pre><code class="language-haskell">data BinaryTree a = BNode (BinaryTree a) (BinaryTree a) | BLeaf a
data ListTree a = ListNode a (List (ListTree a))
</code></pre>

<ul>
  <li>What is a general algorithm for de-recursification?</li>
</ul>

<p>The answers are given at the end of <a href="/src/2015-11-23-Recursive-Types.hs">the attached source code</a>.</p>

<!--

```haskell
--------ANSWERS TO EXERCISES--------

data PreBinaryTree a self = PBNode self self | PBLeaf a
--- Recursive (PreBinaryTree a) === BinaryTree a

data PreListTree a self = PListNode (Pair a (List self))
    -- equivalent to: data PreListTree a self = PListNode a (List self)
--- Recursive (PreListTree a) === ListTree a

{-
    General solution:
        Add a self type parameter.
        Replace any recursive calls with self.
-}

```
-->

<h2 id="conclusion">Conclusion</h2>

<p>OK, so this probably doesn’t have any practical applications. And given how ugly the output of such code is, you’re unlikely to ever see this in real life code, even in an academic language like Haskell.</p>

<p>On the other hand, I hope this hurt your brain a little; it certainly hurt mine. Really, to me, the best part is that with only a simple type system (e.g., non-recursive types), and a single recursive type, you can construct all other simply recursive types. This example shows to me how out of simplicity can grow complexity.</p>

<p>Also, abstract nonsense is <code>Just fun</code> :-).</p>

</article>

<div class="pagination">
  
    <a class="pagination-item older" href="/2015/11/19/Who-Needs-Delta/">Older</a>
  
  
    <a class="pagination-item newer" href="/2015/11/24/What's-A-Number/">Newer</a>
  
</div>

			</main>

			<footer class="footer">
				<small>
					&copy; <time datetime="2015-12-08T23:43:44-08:00">2015</time>. All rights reserved.
				</small>
			</footer>
		</div>
	
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'kavigupta';
  var disqus_identifier = "/2015/11/23/Recursivized-Types/";
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


	</body>
</html>
