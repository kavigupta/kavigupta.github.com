<!DOCTYPE html>
<html lang="en">
	<head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Infsabot Strategy Part 2 &middot; That depends on what the definition of "=" is
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.png">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="That depends on what the definition of "=" is" href="/atom.xml">
</head>

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-68543647-1', 'auto');
  ga('send', 'pageview');

</script>

	<body>
	<link rel="stylesheet" href="/highlighting/styles/default.css">
	<script src="/highlighting/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<div class="container content">
			<header class="masthead">
				<h3 class="masthead-title">
					<div class="header">
						<img src="/public/icon.png" alt="icon" style="width:50px;height:50px;vertical-align: middle;">
						<a href="/" title="Home" style = "vertical-align: middle">&nbsp;That depends on what the definition of "=" is</a>
					</div>
					<small></small>
				</h3>
			</header>

			<main>
				\(\newcommand{\th}{^\mathrm{th}}\)
				\(\newcommand{\false}{\mathrm{F}}\)
				\(\newcommand{\true}{\mathrm{T}}\)
				<article class="post">
  <h1 class="post-title">Infsabot Strategy Part 2</h1>
  <time datetime="2015-12-10T00:00:00-08:00" class="post-date">10 Dec 2015</time>
  <p>OK, so to continue our Infsaboting.</p>

<h3 id="correction">Correction</h3>

<p>I made a mistake last time. I included <code>SwitchInt</code>, a way to switch on values of <code>ExprDir</code>, which is ridiculous since an <code>ExprDir</code> can only be constructed as a constant or an <code>if</code> branch to begin with.</p>

<p>So just imagine that I never did that.</p>

<h2 id="guess-and-check">Guess and Check</h2>

<p>OK, so how should our AI construct these syntax trees? At a very high level, we want to be able to 1) assess trees against collections of trees and 2) modify them randomly. We can represent this as a pair of types:</p>

<pre><code class="language-haskell">asses :: [RP] -&gt; RP -&gt; Double
modify :: RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>I think the implementation of <code>asses</code> should be pretty clear: simply find the win rate (given that we can simulate an unlimited number of games).</p>

<p>Modify, on the other hand, is a little more complicated. There are a few ways a tree can be modified:</p>

<ul>
  <li>Modify the value of a constant to be something else.</li>
  <li>Modify the value of a field to point to something else or a field</li>
  <li>Add leaves to the tree</li>
  <li>Remove leaves as a simplification step</li>
</ul>

<p>It might seem as if some of these factors might be aided by adding a field to everything that tracks typical values of the course of the application at different points within the tree. In this way, one can tell how big a difference between two strategies are. We can actually pretty easily keep track of this separately by recording a list of <code>KnownState</code>s from our simulations. For now, we’ll just keep of all states or some random subset.</p>

<pre><code class="language-haskell">type HistoricalStates = [KnownState]
</code></pre>

<h2 id="shopping-list-for-functions">Shopping List for Functions</h2>

<p>Overall, we want to generate simpler strategies. But what do we mean by “simple”? Well, we can define complexity as the number of leaves of an expression tree:</p>

<pre><code class="language-haskell">complexity :: RP -&gt; Int
</code></pre>

<p>We might also want to be able to check what happens with small changes to individual parameters. To do this, we return a vector of slightly modified values where each parameter is a dimension.</p>

<pre><code class="language-haskell">getDeltas :: Ratio -&gt; RP -&gt; [RP]
</code></pre>

<p>We also want to be able to apply perturbations to an <code>RP</code>:</p>

<pre><code class="language-haskell">applyDeltas :: [Ratio] -&gt; RP -&gt; RP
</code></pre>

<p>Using these two techniques we can find a local maximum by something akin to Euler’s method for differential equations.</p>

<p>We also want to be able to switch between constants and parameters that make sense given context easily. For this, we can provide a typical set of <code>KnownState</code>s that can be used to find some parameter that would be similar and substitute it in. For simplicity, we’ll only change one at a time.</p>

<pre><code class="language-haskell">constantToParameter :: HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>This is a little out of order, but simplification should work in a similar manner, replacing complex sections of tree with constants or parameters.</p>

<pre><code class="language-haskell">simplify :: HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>In fact, <code>simplify</code> can be seen as a more general form of <code>constantToParameter</code>; we can simply require some threshold determining whether or not a parameter or constant is “close enough” to be considered the same as a tree or not.</p>

<pre><code class="language-haskell">data GeneratorParameters = GeneratorParameters {
    closeEnoughThreshold :: Ratio
}

simplify :: GeneratorParameters -&gt; HistoricalStates -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>Finally, we want the ability to complicate a given expression tree.</p>

<p>This can be accomplished most atomically by defining a function <code>complicate</code> that is allowed to make structural but non-effective changes, e.g.,<br />
 - <code>x -&gt; 1 * x, x / 1, 0 + x, x - 0</code><br />
 - <code>x -&gt; if &lt;some bool expression&gt; then x else x</code><br />
 - <code>b -&gt; b &amp;&amp; True, b || False</code></p>

<p>This will accept an integer argument of how much to complicate its tree.</p>

<pre><code class="language-haskell">complicate :: Int -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>Now, in mentioning everything above, glossed over some things. For example, most parameters accept some sort of argument, so generating them requires said argument. Additionally, <code>&lt;some bool expression&gt;</code> will need to actually be filled in in the redundant branch seen above. So we need some way to randomly generate parts of a tree</p>

<pre><code class="language-haskell">randomlyGenerate :: StdGen -&gt; (RP, StdGen)
</code></pre>

<p>In fact, this function is provided by the <code>Random</code> typeclass, so we can instead say</p>

<pre><code class="language-haskell">instance Random RP where
    ...
</code></pre>

<h2 id="an-expr-type-class">An <code>Expr</code> type class</h2>

<p>OK, so if you were looking carefully, that last type didn’t make much sense. I said we needed to be able to generate random elements of various types, but the definition I gave was specifically for <code>RP</code>. In fact, all the definitions I gave apply equally well to any of the various <code>Expr*</code> types.</p>

<p>Let’s therefore collate all these function definitions into a single typeclass:</p>

<pre><code class="language-haskell">class (Random a) =&gt; Expr a where
    complexity :: a -&gt; Int
    getDeltas :: Ratio -&gt; a -&gt; [a]
    applyDeltas :: [Ratio] -&gt; a -&gt; a
    constantToParameter :: HistoricalStates -&gt; a -&gt; StdGen -&gt; (a, StdGen)
    simplify :: HistoricalStates -&gt; a -&gt; StdGen -&gt; (a, StdGen)
    complicate :: Int -&gt; RP -&gt; StdGen -&gt; (RP, StdGen)
</code></pre>

<p>OK, so that’’s it for now. I’ll cover implementation tomorrow after I typecheck this mess!</p>

</article>

<div class="pagination">
  
    <a class="pagination-item older" href="/2015/12/06/Infsabot-Strategy/">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>

			</main>

			<footer class="footer">
				<small>
					&copy; <time datetime="2015-12-12T00:38:30-08:00">2015</time>. All rights reserved.
				</small>
			</footer>
		</div>
	
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'kavigupta';
  var disqus_identifier = "/2015/12/10/Infsabot-Strategy-Part-2/";
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


	</body>
</html>
