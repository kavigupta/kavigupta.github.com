<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>That depends on what the definition of "=" is</title>
 <link href="https://kavigupta.github.io/atom.xml" rel="self"/>
 <link href="https://kavigupta.github.io/"/>
 <updated>2015-12-10T01:24:34-08:00</updated>
 <id>https://kavigupta.github.io</id>
 <author>
   <name>Kavi Gupta</name>
   <email></email>
 </author>

 
 <entry>
   <title>Infsabot Strategy Part 1</title>
   <link href="https://kavigupta.github.io/2015/12/06/Infsabot-Strategy/"/>
   <updated>2015-12-06T00:00:00-08:00</updated>
   <id>https://kavigupta.github.io/2015/12/06/Infsabot-Strategy</id>
   <content type="html">&lt;p&gt;OK, so what is this &lt;em&gt;Infsabot&lt;/em&gt;? Infsabot is a game I designed for people to write programs to play. Basically, it’s like chess, except where each piece acts independently of each other.&lt;/p&gt;

&lt;h2 id=&quot;the-game&quot;&gt;The Game&lt;/h2&gt;

&lt;p&gt;There is a square board where each square is either empty or contains material. The game pieces, robots, require material to stay alive and perform tasks. At each turn, every robot reports which of the following it wants to do:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Noop: The robot does nothing&lt;/li&gt;
  &lt;li&gt;Die: The robot dies&lt;/li&gt;
  &lt;li&gt;Dig: The robot digs to try to extract material&lt;/li&gt;
  &lt;li&gt;Move: The robot can move in one of the four compass directions&lt;/li&gt;
  &lt;li&gt;Fire: The robot can fire a quick-moving projectile (e.g., travel time = 0) in a compass direction&lt;/li&gt;
  &lt;li&gt;Message: The robot can send a quick-moving message in a compass direction&lt;/li&gt;
  &lt;li&gt;Spawn: The robot can create a new robot with its own initial material and appearance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To decide what to do, a robot has access to two things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A picture of the positions around it, to a given distance
    &lt;ul&gt;
      &lt;li&gt;Whether or not the spot contains material&lt;/li&gt;
      &lt;li&gt;Whether or not the spot contains a robot, and it’s appearance (&lt;em&gt;not&lt;/em&gt; it’s team)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A snapshot of its own hard drive, which is a massive relational database between Strings and Strings&lt;/li&gt;
  &lt;li&gt;A list of all messages received&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Crucially, there is no way to tell whether a robot one sees is on one’s own team or not. This must be accomplished through sending an receiving messages.&lt;/p&gt;

&lt;h2 id=&quot;robot-strategies&quot;&gt;Robot strategies&lt;/h2&gt;

&lt;p&gt;A robot strategy can be expressed as a type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;type RobotProgramResult = (RobotAction, InternalState)
type RobotProgram = KnownState -&amp;gt; RobotProgramResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a baseline for human-written strategies, I am going to use an adaptive algorithm to try to generate a strategy. This basic algorithm won’t take into account any of the “human” factors like messages and internal state.&lt;/p&gt;

&lt;p&gt;I will reify the concept of a (non-recursive) robot program by representing it as a long expression tree. The basic concept is something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data ActionType = TDie | TNoop | TFire | TDig | TMoveIn | TSpawn

data RP =
    DefaultRepresentation ActionType |
    ModifyMaterial ExprInt RP |
        -- Applies to Fire, Spawn
    ModifyDirection ExprDir RP |
        -- Applies to Move, Spawn, Fire, Send
    ModifyAppearance ExprInt RP |
        -- Applies to Spawn. RGB treated as a single integer.
    IfRP ExprBool RP RP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, &lt;code&gt;DefaultRepresentation&lt;/code&gt; describes a default representation of the given &lt;code&gt;ActionType&lt;/code&gt;. &lt;code&gt;Modify*&lt;/code&gt; modifies the given field, if it exists, of the given action. The various &lt;code&gt;Expr*&lt;/code&gt; types represent expression tree types, given below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data ExprInt =
    ConstInt Int |
    RobAppear ExprPath ExprInt | -- Coordinate; Default if no robot
    MaterialLevel | -- Current material level
    Age | -- Current Age
    (:*) ExprInt ExprInt |
    (:+) ExprInt ExprInt |
    (:-) ExprInt ExprInt |
    (:/) ExprInt ExprInt |
    Mod ExprInt ExprInt |
    IfInt ExprBool ExprInt ExprInt |
    SwitchInt ExprDir ExprInt ExprInt ExprInt ExprInt

-- Basically [ExprDir]
    -- Written like this to make the tree more explicit
data ExprPath =
    Here |
    Offset ExprDir ExprPath

data ExprDir =
    ConstDir RDirection |
    IfDir ExprBool ExprDir ExprDir

data ExprBool =
    ConstBool Bool |
    CanSee ExprPath |
    MaterialAt ExprPath | -- False if can't see that far
    RobotAt ExprPath | -- False if can't see that far
    EqualInt ExprInt ExprInt |
    GreaterInt ExprInt ExprInt |
    EqualDir RDirection RDirection |
    Not ExprBool |
    (:&amp;amp;) ExprBool ExprBool |
    (:|) ExprBool ExprBool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so that’s a lot of mutually recursive trees. I’m going to skip the boring implementation of &lt;code&gt;eval&lt;/code&gt; for each of these trees, but here’s a simple interface for that purpose:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;class Evaluable given from to where
    eval :: given -&amp;gt; from -&amp;gt; to

instance Evaluable KnownState ExprInt Ratio where
    -- Evaluates to a Ratio, or fraction, for precision reasons.
    -- Round to get an actual integer
    ...
instance Evaluable KnownState ExprBool Bool where
    ...
instance Evaluable KnownState ExprDir RDirection where
    ...
instance Evaluable KnownState ExprPath [RDirection] where
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;constructing-trees&quot;&gt;Constructing Trees&lt;/h2&gt;

&lt;p&gt;OK, so to construct some trees. Here’s a simple move and dig strategy that tries to maximize the digginess of a given robot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;digStrategy
    = IfRP (MaterialAt Here)
        (DefaultRepresentation TDig)
        (ModifyDirection
            (IfDir (MaterialAt (ConstDir N))
                N
                (IfDir (MaterialAt (ConstDir E))
                    E
                    IfDir (MaterialAt (ConstDir S))
                        S
                        W))
            (DefaultRepresentation TMove))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s some damn good looking Scheme—ahem, Infsabot Strategy DSL!&lt;/p&gt;

&lt;p&gt;Anyway, next time I’ll cover how to generate code in the form of this structure. Hopefully, the computer can do most of the heavy lifting!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>What's a number?</title>
   <link href="https://kavigupta.github.io/2015/11/24/What's-A-Number/"/>
   <updated>2015-11-24T00:00:00-08:00</updated>
   <id>https://kavigupta.github.io/2015/11/24/What's-A-Number</id>
   <content type="html">&lt;p&gt;OK, so a bit of a silly question. Of course, we all know what numbers are. But humor me, and try to define a number without using “number”, “quantity”, or anything that refers back to a number itself.&lt;/p&gt;

&lt;p&gt;But, before we learn numbers, we have to first understand something simpler: counting. Couldn’t we define numbers in terms of counting? Well, yes, otherwise I wouldn’t be writing this article.&lt;/p&gt;

&lt;p&gt;Now, to not end up with a forty page book, I’m only going to go over how to define the whole numbers (I’m going to ignore negative integers, fractions, \(\pi\), etc.)&lt;/p&gt;

&lt;p&gt;Basically, a mathematician named Peano had a similar idea back in the 1800s. Back then, even mathematicians didn’t really know what numbers were. Some of them felt that they were simple enough that they didn’t need a definition. On the other hand, some mathematicians liked thinking about numbers in terms of geometry. Like if I draw one line, that’s 1. If I draw another line 2 times as long next to it, that’s 2, etc. It works, but it’s a bit annoying to have to work with geometry all the time. Unless you like drawing, which a lot of people go into math to avoid.&lt;/p&gt;

&lt;p&gt;Anyway, back to Peano. During the 1800s, mathematicians were starting to ask some weirdly difficult questions. Like, how do we know that \(a + b = b + a\)? How do we even know that \(2 + 2 = 4\)? How do we even know that \(4\) exists?&lt;/p&gt;

&lt;p&gt;Well, we need to start somewhere, and Peano decided we needed a few basic Laws Of Mathematics for numbers (mathematicians like the word &lt;em&gt;axiom&lt;/em&gt;). These are rules that are considered self-evident.&lt;/p&gt;

&lt;p&gt;He came up with a total of 9. In advanced 21st century mathematics, there are generally considered to be 5. (No, it didn’t turn out that \(9 = 5\). 4 of the axioms are really part of logic. Stuff like if \(a = b\), \(b = a\). In the 19th century, they didn’t really distinguish logic from math, but now we do.)&lt;/p&gt;

&lt;p&gt;Anyway, let’s go through the Laws!&lt;/p&gt;

&lt;h2 id=&quot;zero-is-a-number&quot;&gt;1. Zero is a Number&lt;/h2&gt;

&lt;p&gt;OK, so \(0\) is a number! Very useful.&lt;/p&gt;

&lt;p&gt;Actually, we don’t have to call this \(0\). Let’s call it &lt;code&gt;Peano&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;Peano&lt;/code&gt; is a number! That’s better! Actually, no, it’s exactly the same.&lt;/p&gt;

&lt;p&gt;All this Law Of Mathematics says is that there is some number. We haven’t really said what this number &lt;em&gt;does&lt;/em&gt; yet. Let’s move on.&lt;/p&gt;

&lt;h2 id=&quot;for-every-number-n-there-is-a-number-ns&quot;&gt;2. For every number \(n\), there is a number \(n_S\).&lt;/h2&gt;

&lt;p&gt;OK, so we know that for every number, there is another number! We have defined here basically the concept of counting. \(n_S\) is the “next number”. Are we done?&lt;/p&gt;

&lt;p&gt;Well, no, because I told you that there are 5 Laws Of Mathematics, and we’ve only covered 2.&lt;/p&gt;

&lt;p&gt;Also, think about it for a second. Have we really defined counting? Does this definition tell us that we can’t, for example, have \(0_S = 0\)?&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/resources/2015-11-24/zero-circ.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No. What it does tell us, however, is that we can’t have two different \(n_S\) for the same \(n\).&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/resources/2015-11-24/non-function.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;there-is-no-number-n-where-ns--0&quot;&gt;3. There is no number \(n\) where \(n_S = 0\)&lt;/h2&gt;

&lt;p&gt;OK! We dealt with that annoying \(0_S = 0\) problem! We’re done! Well, no… Try to think about a problem with this yourself before you move on.&lt;/p&gt;

&lt;p&gt;Here it is: Let’s define \(0_S = 1\). Now, is there anything that says that you can’t have \(\beta_S = 1\) where \(\beta \neq 0\)?&lt;/p&gt;

&lt;p&gt;Well, no. We have some \(0\) (this follows Law of Mathematics #1). We have, \(0_S = 1\), \(\beta_S = 1\), \(1_S = 2\) (by definition), etc. (this follows Law of Mathematics #2). We have no element \(x\) such that \(x_S = 0\) (this follows Law of Mathematics #3).&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/resources/2015-11-24/non-1-to-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Well, we have something that is obviously ridiculous but follows all the Laws. Well, let’s close the loophole!&lt;/p&gt;

&lt;h2 id=&quot;for-any-two-numbers-x-and-y-if-xs--ys-x--y&quot;&gt;4. For any two numbers \(x\) and \(y\), if \(x_S = y_S\), \(x = y\)&lt;/h2&gt;

&lt;p&gt;OK! We’re finally done! No more weird numbers that feed into the regular numbers!&lt;/p&gt;

&lt;p&gt;So now let’s define a few numbers:&lt;/p&gt;

&lt;p&gt;\[0_S = 1\]&lt;br /&gt;
\[1_S = 2\]&lt;br /&gt;
\[2_S = 3\]&lt;br /&gt;
\[3_S = 4\]&lt;/p&gt;

&lt;p&gt;OK, seems to be working. Now let’s define a few more.&lt;/p&gt;

&lt;p&gt;\[\gamma_S = \beta\]&lt;br /&gt;
\[\beta_S = \alpha\]&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;/resources/2015-11-24/two-chains.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Where did those annoying Greek letters come from! Well, we’ve said what can be a number: the \(0, 0_S, 0_{SS}, 0_{SSS}\) etc. And we’ve said that no number is before \(0\). And we’ve said that no two numbers can feed into the same number.&lt;/p&gt;

&lt;p&gt;However, what we haven’t said is that the only numbers are \(0, 0_S, 0_{SS}, 0_{SSS}\), etc. And, guess what? That’s the fifth Law!&lt;/p&gt;

&lt;h2 id=&quot;if-something-is-true-for-n--0-and-its-being-true-for-n-makes-it-true-for-ns-then-it-is-true-for-all-numbers&quot;&gt;5. If something is true for \(n = 0\) and its being true for \(n\) makes it true for \(n_S\), then it is true for all numbers.&lt;/h2&gt;

&lt;p&gt;OK, so this is a little more complicated than the previous examples. But let’s look at a quick example to see how it completes the definition of the numbers. \(\newcommand{\isn}{\uplus}\)&lt;/p&gt;

&lt;p&gt;Let’s look at the symbol \(\isn\). Basically, \(x_\isn = \true\), or true when \(x\) is a number, and \(\false\), or false, whenever it is not. (I got the symbol by typing “fancy math symbols” into Google. As far as I know, it isn’t commonly used.)&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;p&gt;\[0_\isn = \true\\&lt;br /&gt;
1_\isn = \true\\&lt;br /&gt;
2_\isn = \true\\&lt;br /&gt;
\spadesuit_\isn = \false\\&lt;br /&gt;
\diamondsuit_\isn = \false\]&lt;/p&gt;

&lt;p&gt;As you can see, suits of cards are not numbers, but \(0, 1, 2\) are.&lt;/p&gt;

&lt;p&gt;Anyway, the first two axioms can be said as “\(0_\isn\)” and “if \(n_\isn\), then \((n_S)_ \isn\)”&lt;/p&gt;

&lt;p&gt;This means that \(n_\isn\) is true for all numbers.&lt;/p&gt;

&lt;p&gt;Let that sink in for a minute.&lt;/p&gt;

&lt;p&gt;OK, so basically, we proved that all numbers are numbers. But that was just to show that the fifth Law of Mathematics makes sense.&lt;/p&gt;

&lt;p&gt;Now for a better example: let’s look at trying to get rid of those annoying Greek Letters. We defined \(\beta\) as some number which isn’t’ the successor of anything in a chain that comes from 0. Let’s define unbetaness as \(n \neq \beta\). We know that \(0 \neq \beta\), and we know that if \(n \neq \beta\) and \(n\) is a number, \(n_S \neq \beta\). Therefore, no number is equal to \(\beta\), so \(\beta\) is not a number.&lt;/p&gt;

&lt;p&gt;Now we’re actually done! Well, not really, because we still don’t know what \(2 + 2\) is, since we don’t know what \(+\) means. Let’s look at the Laws of Addition.&lt;/p&gt;

&lt;h2 id=&quot;n--n&quot;&gt;1. \(0 + n = n\)&lt;/h2&gt;

&lt;p&gt;Adding nothing to something doesn’t change it. Not particularly crazy stuff.&lt;/p&gt;

&lt;h2 id=&quot;as--b--a--b-s&quot;&gt;2. \(a_S + b = (a + b)_ S\)&lt;/h2&gt;

&lt;p&gt;Counting up one of the numbers does the same thing as counting up the sum. In other words, if you have two piles, adding a stone to one of the piles is the same as adding a stone to the system as a whole.&lt;/p&gt;

&lt;h1 id=&quot;so-what-is-2--2&quot;&gt;So, what &lt;em&gt;is&lt;/em&gt; \(2 + 2\)?&lt;/h1&gt;

&lt;p&gt;\[2 + 2\\&lt;br /&gt;
1_S + 2\\&lt;br /&gt;
(1 + 2)_ S\\&lt;br /&gt;
(0_S + 2)_ S\\&lt;br /&gt;
((0 + 2)_ S)_ S\\&lt;br /&gt;
(2_ S)_ S\\&lt;br /&gt;
3_ S\\&lt;br /&gt;
4\]&lt;/p&gt;

&lt;p&gt;So, you’re wrong, Wikipedia, &lt;a href=&quot;http://en.wikipedia.org/wiki/2+2=5&quot;&gt;\(2 + 2\) is &lt;em&gt;not&lt;/em&gt; 5!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Anyway, the real point is that while before, you probably thought that \(2 + 2 = 4\) was a basic fact, a Law of Mathematics, now you know that it is just a deduction based on a few other, simpler, laws.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Recursivized Types</title>
   <link href="https://kavigupta.github.io/2015/11/23/Recursivized-Types/"/>
   <updated>2015-11-23T00:00:00-08:00</updated>
   <id>https://kavigupta.github.io/2015/11/23/Recursivized-Types</id>
   <content type="html">&lt;p&gt;So, a short break from \(\varepsilon—\delta\).&lt;/p&gt;

&lt;p&gt;Anyway, I’m going to look at Algebraic types in this section. Specifically, I am going to use Haskell types.&lt;/p&gt;

&lt;p&gt;The provided code is all actual Haskell, in fact, I’m going to have to de-import the standard libraries because some of this is actually defined there. You can find all the code &lt;a href=&quot;/src/2015-11-23-Recursive-Types.hs&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;!--
```haskell
{-# LANGUAGE FlexibleContexts, UndecidableInstances #-}

import Prelude(Show, show, (++))
```
--&gt;

&lt;h2 id=&quot;algebraic-types&quot;&gt;Algebraic types&lt;/h2&gt;

&lt;p&gt;I’ll start with a quick go-over of Haskell types. If you already know Haskell, feel free to skip this section.&lt;/p&gt;

&lt;h3 id=&quot;enumeration-types&quot;&gt;Enumeration types&lt;/h3&gt;

&lt;p&gt;Some types are enumerations of potential values.&lt;/p&gt;

&lt;p&gt;A quick example is the trivial singleton type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Singleton = Single
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is to be read as “there exists a type Singleton, which contains one element named Single.” The “deriving show” part is Haskell book keeping for those following along on their interpreters to be able to see things&lt;/p&gt;

&lt;p&gt;Another example is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Void
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is to be read as “there exists a type Void with no possible elements”&lt;/p&gt;

&lt;p&gt;Yet another type is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Bool = False | True
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is to be read as “there exists a type Bool with the possible elements True and False.”&lt;/p&gt;

&lt;h3 id=&quot;structure-types&quot;&gt;Structure types&lt;/h3&gt;

&lt;p&gt;Types can be used as as structures, as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Wrapper a = Wrap a
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is to be read as “for every type &lt;code&gt;a&lt;/code&gt; there exists a type &lt;code&gt;(Wrapper a)&lt;/code&gt; with a single type constructor &lt;code&gt;Wrap&lt;/code&gt; that takes an &lt;code&gt;a&lt;/code&gt;”&lt;/p&gt;

&lt;p&gt;A more complicated structure is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Pair a b = ConsPair a b
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is similar to the previous one except that it contains two possible elements which can be of two different types.&lt;/p&gt;

&lt;h3 id=&quot;aside-kinds&quot;&gt;Aside: Kinds&lt;/h3&gt;

&lt;p&gt;Algebraic types have kinds.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;Singleton&lt;/code&gt;, &lt;code&gt;Void&lt;/code&gt;, and &lt;code&gt;Bool&lt;/code&gt; are concrete types in their own right.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Wrapper&lt;/code&gt; needs a type before it can become a type (nothing can be a &lt;code&gt;Wrapper&lt;/code&gt; by itself).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Pair&lt;/code&gt; needs two types before it can become a type (nothing can be a &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Pair Bool&lt;/code&gt; by itself).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We refer to the latter two cases as “higher-kinded types.”&lt;/p&gt;

&lt;p&gt;We say that &lt;code&gt;Singleton&lt;/code&gt;, &lt;code&gt;Void&lt;/code&gt;, etc. have kind &lt;code&gt;*&lt;/code&gt;. Types that need one type added on the end to be complete, such as &lt;code&gt;Wrapper&lt;/code&gt; or &lt;code&gt;Pair Bool&lt;/code&gt; have kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. Types such as &lt;code&gt;Pair&lt;/code&gt;, which needs two types to be complete, have kind &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note also that types such as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data TwoOfSame a = ConsTwoOfSame a a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;have kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; rather than &lt;code&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; because they only take one type argument. &lt;code&gt;TwoOfSame Bool Singleton&lt;/code&gt; wouldn’t make any sense.&lt;/p&gt;

&lt;h3 id=&quot;mixing-structures-and-enumerations&quot;&gt;Mixing Structures and Enumerations&lt;/h3&gt;

&lt;p&gt;Algebraic types are a generalization of both systems, in which you can have multiple constructors, each of which can contain zero or multiple arguments.&lt;/p&gt;

&lt;p&gt;A canonical example combines both forms to create something resembling the concept of &lt;code&gt;null&lt;/code&gt; from Java or &lt;code&gt;None&lt;/code&gt; from Python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Maybe a = Nothing | Just a
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, there is a combination of the enumeration and structure style. Interestingly, while, for example, &lt;code&gt;Just True :: Maybe Bool&lt;/code&gt; (&lt;code&gt;::&lt;/code&gt; is to be read as “is of type”), &lt;code&gt;Nothing :: Maybe a&lt;/code&gt;, which means that it can take on any &lt;code&gt;Just&lt;/code&gt; type (this is key to what we will do later).&lt;/p&gt;

&lt;h2 id=&quot;recursive-algebraic-types&quot;&gt;Recursive Algebraic types&lt;/h2&gt;

&lt;p&gt;Recursive types are similar to the examples shown, except that they can also contain themselves. For example, the not particularly efficient definition of the natural numbers (&lt;a href=&quot;https://en.wikipedia.org/wiki/Peano_axioms&quot;&gt;a natural number is either zero or the successor of another natural number&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Nat = Zero | Succ Nat
    deriving Show
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another algebraic type is a stream, which is defined as follows, which is basically an infinite list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Stream a = ConsStream a (Stream a)
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This only works because you can define values as follows, where in each case the same variable name refers to the same value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;trues = ConsStream True trues
falses = ConsStream False falses
alternating = ConsStream True (ConsStream False alternating)

elementAt (ConsStream value rest) Zero = value
elementAt (ConsStream value rest) (Succ x) = elementAt rest x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if you ask for the (fifth element of trues), that reduces to the (fourth element of (the rest of trues)) which reduces to (the fourth element of trues), etc., until you get to the value &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A potentially terminating list can be represented as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data List a = Nil | Cons a (List a)
    deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the list can possibly terminate because you can stop with &lt;code&gt;Nil&lt;/code&gt;. For example, you can represent &lt;code&gt;[True, False, False]&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;exampleList = Cons True (Cons False (Cons False Nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also use stream-like circular definition for a list too, so streams are just a subset of lists.&lt;/p&gt;

&lt;h2 id=&quot;higher-kinded-type-parameters&quot;&gt;Higher-kinded type parameters&lt;/h2&gt;

&lt;p&gt;OK, one final bit of craziness before we get to our actual example. Let’s say we want to create a type representing the shape of another type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Shape f = Structure (f Singleton)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we, for example, look at &lt;code&gt;Shape List&lt;/code&gt;, we get the values &lt;code&gt;Structure Nil&lt;/code&gt;, &lt;code&gt;Structure (Cons Single Nil)&lt;/code&gt;, &lt;code&gt;Structure (Cons Single (Cons Single Nil))&lt;/code&gt;, etc. Basically, we get a picture of what the type looks like independent of its elements.&lt;/p&gt;

&lt;p&gt;Notice that on the right side of that equation we have &lt;code&gt;(f Singleton)&lt;/code&gt; as a concrete value, meaning that &lt;code&gt;f&lt;/code&gt; is of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. Therefore, &lt;code&gt;Shape&lt;/code&gt; is of kind &lt;code&gt;(* -&amp;gt; *) -&amp;gt; *&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another example of a &lt;code&gt;(* -&amp;gt; *) -&amp;gt; *&lt;/code&gt; is the &lt;code&gt;NullOf&lt;/code&gt; type, which filters a type for only its nullary constructors, those which do not take a value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data NullOf f = Null (f Void)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, the only possible value of &lt;code&gt;NullOf List&lt;/code&gt; is &lt;code&gt;Null Nil&lt;/code&gt; and the only possible value of &lt;code&gt;NullOf Just&lt;/code&gt; is &lt;code&gt;Null Nothing&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-general-encoding-of-recursive-types&quot;&gt;A general encoding of Recursive Types&lt;/h2&gt;

&lt;p&gt;You might notice a correspondence between the types &lt;code&gt;Maybe&lt;/code&gt; and &lt;code&gt;Nat&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;    data Maybe a = Nothing | Just a
    data Nat = Zero | Succ Nat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, &lt;code&gt;Nat&lt;/code&gt; is just &lt;code&gt;Maybe Nat&lt;/code&gt;. We can encode the conversion from &lt;code&gt;Maybe&lt;/code&gt; to &lt;code&gt;Nat&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Recursive f = Recurse (f (Recursive f))
&lt;/code&gt;&lt;/pre&gt;

&lt;!--
```haskell
instance (Show (f (Recursive f))) =&gt; Show (Recursive f) where
    show (Recurse x) = &quot;Recurse (&quot; ++ show x ++ &quot;)&quot;
```
--&gt;

&lt;p&gt;This definition means that for all types &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;, there exists a type called &lt;code&gt;Recursive f&lt;/code&gt; (let’s call this &lt;code&gt;rf&lt;/code&gt; for now) which contains a single element whose type is &lt;code&gt;f rf&lt;/code&gt;. In other words, &lt;code&gt;Recursive&lt;/code&gt; takes a type and returns a recursive version of that type.&lt;/p&gt;

&lt;p&gt;Constructing a value of &lt;code&gt;Recursive *&lt;/code&gt; at first seems difficult. For example, let us look at &lt;code&gt;Recursive Maybe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To construct a type of &lt;code&gt;Recursive Maybe&lt;/code&gt; we need to have an element of type &lt;code&gt;Maybe (Recursive Maybe)&lt;/code&gt;. The only element of this we have is &lt;code&gt;Nothing :: Maybe a&lt;/code&gt;. We can therefore construct the value &lt;code&gt;Recurse Nothing :: Recursive Maybe&lt;/code&gt;. Using this value we can construct the value &lt;code&gt;Just (Recurse Nothing) :: Maybe (Recursive Maybe)&lt;/code&gt; and therefore the value &lt;code&gt;Recurse (Just (Recurse Nothing)) :: Recursive Maybe&lt;/code&gt;. We can continue to build values in this manner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;zero' = Recurse Nothing
one' = Recurse (Just zero')
two' = Recurse (Just one')
three' = Recurse (Just two')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that I used the names for numbers for these. This is to demonstrate their correspondence with the natural numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;zero = Zero
one = Succ Zero
two = Succ one
three = Succ two
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically, &lt;code&gt;Zero&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; is &lt;code&gt;Recurse . Just&lt;/code&gt;, where &lt;code&gt;.&lt;/code&gt; is function composition.&lt;/p&gt;

&lt;p&gt;Interestingly, there is another possible value of these types&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;omega' = Recurse (Just omega')
omega = Succ omega
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The name &lt;code&gt;omega&lt;/code&gt; is used because this number is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Ordinal_number&quot;&gt;one particular kind of infinity&lt;/a&gt;. because of the way that it reacts to this definition of comparison:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;_ &amp;lt; Zero        = False
Zero &amp;lt; Succ _   = True
Succ x &amp;lt; Succ y = x &amp;lt; y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, &lt;code&gt;x &amp;lt; omega&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; defined by &lt;code&gt;Succ (Succ (Succ ... Succ (Zero)))&lt;/code&gt;. Note that &lt;code&gt;omega &amp;lt; omega&lt;/code&gt; will never evaluate since &lt;code&gt;omega &amp;lt; omega&lt;/code&gt; reduces to &lt;code&gt;Succ omega &amp;lt; Succ omega&lt;/code&gt;, which reduces to &lt;code&gt;omega &amp;lt; omega&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;recursivizing-types&quot;&gt;Recursivizing Types&lt;/h2&gt;

&lt;p&gt;To begin with, let’s look at the entirely contrived types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data Constant a = Const
    deriving (Show)
data Empty a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that there is one possible value for &lt;code&gt;Constant (Recursvie Constant)&lt;/code&gt;, which is &lt;code&gt;Const&lt;/code&gt;. Therefore, the only possible value for &lt;code&gt;Recursive Constant&lt;/code&gt; is &lt;code&gt;Recurse Const&lt;/code&gt;. Therefore, &lt;code&gt;Recursive Constant&lt;/code&gt; is similar to the Singleton:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;single = Single
single' = Recurse Const
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, there is no value &lt;code&gt;Empty (Recursive Empty)&lt;/code&gt; possible, so there is no possible value of &lt;code&gt;Recursive Empty&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let’s now look at a less contrived &lt;code&gt;* -&amp;gt; *&lt;/code&gt; type, Wrapper, and see how it works. &lt;code&gt;Recursive Wrapper&lt;/code&gt; requires a value of &lt;code&gt;Wrapper (Recursive Wrapper)&lt;/code&gt; in order to initialize. There is in fact only one way to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;wrappedRecurse = Recurse (Wrap wrappedRecurse)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This type is also basically &lt;code&gt;Singleton&lt;/code&gt; since it only has one value&lt;/p&gt;

&lt;p&gt;We can also use the partial application of &lt;code&gt;Pair&lt;/code&gt; to a single type variable &lt;code&gt;a&lt;/code&gt; and then construct a recursion of the pair. We can then analyze values of &lt;code&gt;Recurse (Pair Bool)&lt;/code&gt;. At first, this doesn’t seem to work any better than &lt;code&gt;Recurse Wrap&lt;/code&gt; because we need a value of &lt;code&gt;Pair Bool (RPair Bool)&lt;/code&gt; before we can create a value of &lt;code&gt;RPair Bool&lt;/code&gt;. However, since in this case each value also has a &lt;code&gt;Bool&lt;/code&gt;, these form a stream:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;trues' = Recurse (ConsPair True trues')
falses' = Recurse (ConsPair False falses')
alternating' = Recurse (ConsPair True (Recurse (ConsPair False alternating')))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is remarkably similar to our previous definitions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;trues = ConsStream True trues
falses = ConsStream False falses
alternating = ConsStream True (ConsStream False alternating)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;finding-the-base-type-for-recursive-types&quot;&gt;Finding the base type for recursive types&lt;/h2&gt;

&lt;p&gt;So now we know (I’m using \(\equiv\) to mean that two types have the same structure):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Recurse Maybe&lt;/code&gt; \(\equiv\) &lt;code&gt;Nat&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Recurse Constant&lt;/code&gt; \(\equiv\) &lt;code&gt;Singleton&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Recurse Wrapper&lt;/code&gt; \(\equiv\) &lt;code&gt;Singleton&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Recurse Empty&lt;/code&gt; \(\equiv\) &lt;code&gt;Void&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Recurse Constant&lt;/code&gt; \(\equiv\) &lt;code&gt;Stream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But what is &lt;code&gt;List&lt;/code&gt; equivalent to? We can look again at the definition of a list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data List a = Nil | Cons a (List a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so we need to have a type parameter representing the &lt;code&gt;a&lt;/code&gt; and another to be eaten by &lt;code&gt;Recurse&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data PreList a self = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we need to have some element &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data PreList a self = PreNil | ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we just need something to combine both the first and rest of the list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data PreList a self = PreNil | PreCons a self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey, what’s on the right of the list looks a lot like a &lt;code&gt;Maybe&lt;/code&gt; with two values instead of one! Here’s a final implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data PreList a self = PreList (Maybe (Pair a self))
    deriving (Show)

type RecurseList a = Recursive (PreList a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redoing our &lt;code&gt;[True, False, False]&lt;/code&gt; example, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;exampleList'
    = Recurse (PreList (Just (ConsPair
        True
        (Recurse (PreList (Just (ConsPair
            False
            (Recurse (PreList (Just (ConsPair
                False
                (Recurse (PreList Nothing)))))))))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No reasonable person (except (maybe (a (Lisp (fanatic))))) would say that the above code is pretty, but it is clear that &lt;code&gt;Recursive (PreList a)&lt;/code&gt; \(\equiv\) &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Find the de-recursified forms of&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-haskell&quot;&gt;data BinaryTree a = BNode (BinaryTree a) (BinaryTree a) | BLeaf a
data ListTree a = ListNode a (List (ListTree a))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;What is a general algorithm for de-recursification?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The answers are given at the end of &lt;a href=&quot;/src/2015-11-23-Recursive-Types.hs&quot;&gt;the attached source code&lt;/a&gt;.&lt;/p&gt;

&lt;!--

```haskell
--------ANSWERS TO EXERCISES--------

data PreBinaryTree a self = PBNode self self | PBLeaf a
--- Recursive (PreBinaryTree a) === BinaryTree a

data PreListTree a self = PListNode (Pair a (List self))
    -- equivalent to: data PreListTree a self = PListNode a (List self)
--- Recursive (PreListTree a) === ListTree a

{-
    General solution:
        Add a self type parameter.
        Replace any recursive calls with self.
-}

```
--&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;OK, so this probably doesn’t have any practical applications. And given how ugly the output of such code is, you’re unlikely to ever see this in real life code, even in an academic language like Haskell.&lt;/p&gt;

&lt;p&gt;On the other hand, I hope this hurt your brain a little; it certainly hurt mine. Really, to me, the best part is that with only a simple type system (e.g., non-recursive types), and a single recursive type, you can construct all other simply recursive types. This example shows to me how out of simplicity can grow complexity.&lt;/p&gt;

&lt;p&gt;Also, abstract nonsense is &lt;code&gt;Just fun&lt;/code&gt; :-).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Who Needs Delta? Defining the Hyper-Real Numbers</title>
   <link href="https://kavigupta.github.io/2015/11/19/Who-Needs-Delta/"/>
   <updated>2015-11-19T00:00:00-08:00</updated>
   <id>https://kavigupta.github.io/2015/11/19/Who-Needs-Delta</id>
   <content type="html">&lt;p&gt;\(\renewcommand{\ep}{\varepsilon}\)&lt;br /&gt;
\(\renewcommand{\d}{\mathrm d}\)&lt;/p&gt;

&lt;p&gt;In high school Calculus, solving differential equations often involves something like the following:&lt;/p&gt;

&lt;p&gt;\[\frac{\d y}{\d x} = \frac{y}{x}\]&lt;/p&gt;

&lt;p&gt;\[\frac{\d y}{y} = \frac{\d x}{x}\]&lt;/p&gt;

&lt;p&gt;\[\int \frac{\d y}{y} = \int \frac{\d x}{x}\]&lt;/p&gt;

&lt;p&gt;\[\int \log y = c + \log x\]&lt;/p&gt;

&lt;p&gt;\[\int y = kx\]&lt;/p&gt;

&lt;p&gt;Now, I don’t know about anyone else, but this abuse of notation really bothered me at first. Everyone knows that \(\d x\) isn’t an actual number by itself, but we seem to use it all the time as an independent variable.&lt;/p&gt;

&lt;h2 id=&quot;fluxions-and-limits&quot;&gt;Fluxions and Limits&lt;/h2&gt;

&lt;p&gt;Well, as it turns out, early mathematicians had the same problem with Newton’s original formulation of Calculus, in which he called these infinitesimal quantities &lt;a href=&quot;https://en.wikipedia.org/wiki/Method_of_Fluxions&quot;&gt;“fluxions”&lt;/a&gt;. His explanation was that they were quantities which “flowed” to 0 from before to after he took a derivative.&lt;/p&gt;

&lt;p&gt;Obviously, in modern mathematics, this could not stand, and we got the following definition:&lt;/p&gt;

&lt;p&gt;\[\lim_{x \to a} f(x) = L \iff (\forall \ep &amp;gt; 0)(\exists \delta)(|x - d| &amp;lt; \delta \implies |f(x) - L| &amp;lt; \ep) \]&lt;/p&gt;

&lt;p&gt;\[f’(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h} \]&lt;/p&gt;

&lt;p&gt;This system, known as \(\ep–\delta\), has been an important part of mathematics ever since it was defined.&lt;/p&gt;

&lt;p&gt;I find this equation particularly elegant; it places the idea of limits and derivatives firmly in the language of set theory, and does so in a simple manner that, after some thought, is somewhat intuitive.&lt;/p&gt;

&lt;h2 id=&quot;back-to-infinitesimals&quot;&gt;Back to Infinitesimals&lt;/h2&gt;

&lt;p&gt;However, when we think about what the velocity of a particle in free fall, we generally don’t think in terms of finding some \(\delta\) for every \(\ep\). I generally tend to find it easier to think in terms of a small change in position over a small change in time.&lt;/p&gt;

&lt;p&gt;In fact, there is a way to formalize this relationship, found in the field of &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-standard_analysis&quot;&gt;non-standard analysis&lt;/a&gt;. To do so, we introduce an infinitesimal element, which is known as \(\ep\). This element has the property that&lt;/p&gt;

&lt;p&gt;\[(\forall n \in \mathbb{N^+})(0 &amp;lt; \ep &amp;lt; \frac{1}{n})\]&lt;/p&gt;

&lt;p&gt;We can therefore define addition and subtraction as simple vector addition and subtraction over \(\{1, \ep\}\) fairly simply, in a similar manner to complex addition and subtraction.&lt;/p&gt;

&lt;h2 id=&quot;ep2&quot;&gt;\(\ep^2\)&lt;/h2&gt;
&lt;p&gt;Multiplication is a little more complicated. We know that&lt;/p&gt;

&lt;p&gt;\[(a + b\ep)(c + d\ep) = ac + (ad + bc)\ep + bd \ep^2\]&lt;/p&gt;

&lt;p&gt;but what should \(\ep^2\) be? If we decide to keep the result within our new vector-like field, we end up with the equation \(\ep^2 = a\ep + b\), for real \(a, b\). I’ll spare you the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypercomplex_number#Two-dimensional_real_algebras&quot;&gt;derivation&lt;/a&gt;, but it turns out that there are only three different systems we can get out of this formula. Two are useless for our purposes, being the complex numbers and something called the split-complex numbers, in which there is some \(j^2 = 1, j \neq \pm 1\). The last, the Dual Numbers, is a system in which \(\ep^2 = 0\).&lt;/p&gt;

&lt;h2 id=&quot;dual-numbers&quot;&gt;Dual Numbers&lt;/h2&gt;

&lt;p&gt;Dual Numbers at first seem quite promising. The idea that \(\d x^2 = 0\) sounds pretty similar to the notion of higher order differentials vanishing to 0. However, there are a few problems. First of all, the second derivative \(\frac{\d^2 x}{\d x^2}\) contains second degree differentials on both the numerator and the denominator, which means that it would vanish to 0.&lt;/p&gt;

&lt;p&gt;Secondly, and more disturbingly, \(\ep^{-1}\) is not defined in the dual numbers. This is because of the following. Define \(\omega = \ep ^ {-1}\). Then&lt;/p&gt;

&lt;p&gt;\[\omega\ep = 1\]&lt;br /&gt;
\[\omega^2\ep^2 = 1\]&lt;br /&gt;
\[\omega^2 0 = 1\]&lt;/p&gt;

&lt;p&gt;Which is an obvious contradiction. Therefore, the Dual Numbers are not a field and therefore not what we are looking for.&lt;/p&gt;

&lt;h2 id=&quot;full-system-of-infinitesimals&quot;&gt;Full System of Infinitesimals&lt;/h2&gt;

&lt;p&gt;Obviously, we need to define \(\ep^2\). So let’s just define it as \(\ep^2\). Same for \(\ep^3, \ep^4, \ep^5, \ldots\). We also, by fiat, define \(\ep^{-1} = \omega\). This of course introduces \(\omega^2, \omega^3, \omega^4,\ldots\).&lt;/p&gt;

&lt;p&gt;This set is called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperreal_number&quot;&gt;Hyperreals&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, it might at first appear that we have infinitesimals corresponding to every integer. Some Haskell programmers out there might be thinking in terms of infinite lists (I know that was &lt;em&gt;my&lt;/em&gt; first thought at least). However, here’s a problem: what’s \(\sqrt{\ep}\)?&lt;/p&gt;

&lt;h2 id=&quot;level-comparison&quot;&gt;Level comparison&lt;/h2&gt;

&lt;p&gt;Before we can fully analyze what \(\sqrt{\ep}\) means, we should define some notion of comparability. For example, we might want to define some notion of something being infinitesimal compared to something else. We can define \(\ll\), read “infinitesimal compared to” as follows:&lt;/p&gt;

&lt;p&gt;\[x \ll 1 \iff (\forall n \in \mathbb{N})(|x| &amp;lt; \frac{1}{n})\]&lt;br /&gt;
\[x \ll y \iff y \neq 0 \wedge \frac{x}{y} \ll 1\]&lt;/p&gt;

&lt;p&gt;Note that we decided to use the absolute value. Then, we can say \(0 \ll -1\). This is to allow for negative numbers to be compared in this way; the sign is simply ignored.&lt;/p&gt;

&lt;p&gt;We can also define the comparators \(\gg\) and \(\bot\), read “infinite compared to” and “comparable to” as:&lt;/p&gt;

&lt;p&gt;\[x \gg y \iff y \ll x\]&lt;br /&gt;
\[x \bot y \iff \neg (x \ll y) \wedge \neg (x \gg y)\]&lt;/p&gt;

&lt;p&gt;The following proofs are left as an exercise to the reader:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Exactly one of \(x \gg y\), \(x \ll y\), and \(x \bot y\) is true&lt;/li&gt;
  &lt;li&gt;\(\ll\) is transitive.&lt;/li&gt;
  &lt;li&gt;\(x \ll y \iff kx \ll ky\) for every \(k \neq 0\)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;all-powers-of-infinitesimals&quot;&gt;All powers of infinitesimals&lt;/h2&gt;

&lt;p&gt;Now we can analyze what \(\sqrt{\ep}\) means. We know that since \(\ep \ll 1\), \(\sqrt{\ep} \ll 1\). We also know that since \(\frac{\ep}{\sqrt{\ep}} = \sqrt{\ep} \ll 1\), \(\ep \ll \sqrt{\ep}\). We now know that&lt;/p&gt;

&lt;p&gt;\[\ep \ll \sqrt\ep \ll 1\]&lt;/p&gt;

&lt;p&gt;This means that \(\sqrt\ep\) is on a separate level of infinitesimal than any of the integral powers of \(\ep\). Since similar proofs can be constructed for all rational powers, and therefore for all real powers (yes, we have to go back to \(\ep—\delta\) for this), the hyper-reals therefore have as many levels as there are real numbers.&lt;/p&gt;

&lt;h2 id=&quot;derivatives&quot;&gt;Derivatives&lt;/h2&gt;

&lt;p&gt;OK, so I know I promised you at the beginning of this section that this would all eventually lead to a more intuitive approach to derivatives. Unfortunately, however, this is far too long of a post already. I’ll cover derivatives in the next section.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ancient Greek Abstract Algebra&#58; Introduction</title>
   <link href="https://kavigupta.github.io/2015/10/06/Ancient-Greek-Abstract-Algebra-Introduction/"/>
   <updated>2015-10-06T00:00:00-07:00</updated>
   <id>https://kavigupta.github.io/2015/10/06/Ancient-Greek-Abstract-Algebra-Introduction</id>
   <content type="html">&lt;p&gt;Note: I’ve put the Ancient Greek Abstract Algebra series on hold for now. Please take a look at some of my other post(s).&lt;/p&gt;

&lt;h2 id=&quot;modern-constructions-of-mathbbn&quot;&gt;Modern constructions of &lt;script type=&quot;math/tex&quot;&gt;\mathbb{N}&lt;/script&gt;&lt;/h2&gt;

&lt;p&gt;The natural numbers are taught to children as a basic facet of mathematics. One of the first things we learn is how to count. In fact, the name “Natural Numbers” itself implies that the natural numbers are basic.&lt;/p&gt;

&lt;p&gt;However, modern mathematicians seem to have trouble with accepting the natural numbers as first class features of mathematics. In fact, there are not one but two common definitions of the naturals that can be used to prove the Peano Axioms (the basic axioms from which most of number theory can be proven).&lt;/p&gt;

&lt;h3 id=&quot;church-numerals&quot;&gt;Church Numerals&lt;/h3&gt;

&lt;p&gt;\[0 = f \mapsto (t \mapsto t)\]&lt;/p&gt;

&lt;p&gt;\[S(n) = f \mapsto (f \circ n(f))\]&lt;/p&gt;

&lt;p&gt;In this way, the church numeral &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is defined as the function that takes a function and outputs the &lt;script type=&quot;math/tex&quot;&gt;n\th&lt;/script&gt; repeated application of it.&lt;/p&gt;

&lt;h3 id=&quot;set-theory-numerals&quot;&gt;Set Theory Numerals&lt;/h3&gt;

&lt;p&gt;\[0 = \{\{\}\}\]&lt;br /&gt;
\[S(n) = n \cup \{n\}\]&lt;/p&gt;

&lt;p&gt;The set theoretic numerals are therefore defined as the set of all the elements before them along with the empty set.&lt;/p&gt;

&lt;h2 id=&quot;ancient-greek-abstract-algebra&quot;&gt;Ancient Greek Abstract Algebra&lt;/h2&gt;

&lt;p&gt;A modern mathematician would justify the definition of the natural numbers as a way to base an inherently complicated system with an infinite number of elements on a far simpler system containing only a few axioms.&lt;/p&gt;

&lt;p&gt;However, modern mathematicians’ discomfort with numbers and desire for algebraic constructions, to the uninitiated, can often seem bizarre. In fact, my first thought when I learned about the construction of the natural numbers was to think of another type of construction: Euclid’s compass and straightedge.&lt;/p&gt;

&lt;p&gt;Personally, I like modern algebra, but I don’t like geometry. Whenever I see a problem in geometry, I immediately try to transform it into an algebraic problem by introducing coordinates. I used to think that I didn’t like geometry because it is unsystematic. However, I have come to realize that a large part of my aversion has to do with language.&lt;/p&gt;

&lt;h2 id=&quot;language&quot;&gt;Language&lt;/h2&gt;

&lt;p&gt;Algebra has an important modern advantage over geometry: a symbolic language. For example, the following is the converse of the Pythagorean theorem, quoted from &lt;a href=&quot;http://aleph0.clarku.edu/~djoyce/java/elements/bookI/propI48.html&quot;&gt;Professor D.E. Joyce’s page at Clark University &lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If in a triangle the square on one of the sides equals the sum of the squares on the remaining two sides of the triangle, then the angle contained by the remaining two sides of the triangle is right.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In symbols, this statement would be&lt;/p&gt;

&lt;p&gt;\[AC^2 = AB^2 + BC^2 \implies AB \perp BC\]&lt;/p&gt;

&lt;p&gt;I will say, and I think without the guilt of modern arrogance, that this formulation is much simpler. While it does require a little more background knowledge than the sentence form (one must know what the symbols represent), it is much shorter and can generalize to more than three variable quantities easily.&lt;/p&gt;

&lt;p&gt;For example, try putting the quadratic formula &lt;script type=&quot;math/tex&quot;&gt;ax^2 + bx + c = 0 \implies x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}&lt;/script&gt; in a language with no concept of symbolic operations or variable names. The simplest result I can think of (with &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; flipped to the other side to avoid saying “zero”) is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the sum of the the product of the square of a number and some coefficient and the number and some other coefficient is equal to some value, the number is equal to the quotient between the difference of a number whose square is equal to the sum between the square of the coefficient of the number and four times the product of the coefficient of the square of the number and the value and the coefficient of the number and twice the coefficient of the square of the number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I can conclude with some confidence that putting Euclidean geometry into the language of abstract mathematics will make it more manageable.&lt;/p&gt;

&lt;p&gt;Hey, it might even break down anti-geometry prejudices of people like me.&lt;/p&gt;
</content>
 </entry>
 

</feed>
